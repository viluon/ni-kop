{"pandoc-api-version":[1,22,1],"meta":{"author":{"t":"MetaInlines","c":[{"t":"Str","c":"Ondřej"},{"t":"Space"},{"t":"Str","c":"Kvapil"}]},"title":{"t":"MetaInlines","c":[{"t":"Str","c":"NI-KOP"},{"t":"Space"},{"t":"Str","c":"–"},{"t":"Space"},{"t":"Str","c":"úkol"},{"t":"Space"},{"t":"Str","c":"5"}]}},"blocks":[{"t":"Header","c":[1,["kombinatorická-optimalizace-problém-vážené-splnitelnosti-booleovské-formule",[],[]],[{"t":"Str","c":"Kombinatorická"},{"t":"Space"},{"t":"Str","c":"optimalizace:"},{"t":"Space"},{"t":"Str","c":"problém"},{"t":"Space"},{"t":"Str","c":"vážené"},{"t":"Space"},{"t":"Str","c":"splnitelnosti"},{"t":"Space"},{"t":"Str","c":"booleovské"},{"t":"Space"},{"t":"Str","c":"formule"}]]},{"t":"Header","c":[2,["zadání",[],[]],[{"t":"Str","c":"Zadání"}]]},{"t":"Header","c":[3,["pokyny",[],[]],[{"t":"Str","c":"Pokyny"}]]},{"t":"Para","c":[{"t":"Str","c":"Problém"},{"t":"Space"},{"t":"Str","c":"řešte"},{"t":"Space"},{"t":"Str","c":"některou"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Str","c":"pokročilých"},{"t":"Space"},{"t":"Str","c":"heuristik:"}]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Str","c":"simulované"},{"t":"Space"},{"t":"Str","c":"ochlazování"}]}],[{"t":"Plain","c":[{"t":"Str","c":"genetický"},{"t":"Space"},{"t":"Str","c":"algoritmus"}]}],[{"t":"Plain","c":[{"t":"Str","c":"tabu"},{"t":"Space"},{"t":"Str","c":"prohledávání"}]}]]},{"t":"Para","c":[{"t":"Str","c":"Po"},{"t":"Space"},{"t":"Str","c":"nasazení"},{"t":"Space"},{"t":"Str","c":"heuristiky"},{"t":"Space"},{"t":"Str","c":"ověřte"},{"t":"Space"},{"t":"Str","c":"její"},{"t":"Space"},{"t":"Str","c":"vlastnosti"},{"t":"Space"},{"t":"Str","c":"experimentálním"},{"t":"Space"},{"t":"Str","c":"vyhodnocením,"},{"t":"SoftBreak"},{"t":"Str","c":"které"},{"t":"Space"},{"t":"Str","c":"přesvědčivě"},{"t":"Space"},{"t":"Str","c":"doloží,"},{"t":"Space"},{"t":"Str","c":"jakou"},{"t":"Space"},{"t":"Str","c":"třídu"},{"t":"Space"},{"t":"Str","c":"(rozsah,"},{"t":"Space"},{"t":"Str","c":"velikosti…)"},{"t":"Space"},{"t":"Str","c":"instancí"},{"t":"Space"},{"t":"Str","c":"heuristika"},{"t":"SoftBreak"},{"t":"Str","c":"zpracovává."},{"t":"Space"},{"t":"Str","c":"Zejména"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"případě"},{"t":"Space"},{"t":"Str","c":"použití"},{"t":"Space"},{"t":"Str","c":"nestandardních,"},{"t":"Space"},{"t":"Str","c":"např."},{"t":"Space"},{"t":"Str","c":"originálních"},{"t":"Space"},{"t":"Str","c":"technik"},{"t":"SoftBreak"},{"t":"Str","c":"doložte"},{"t":"Space"},{"t":"Str","c":"jejich"},{"t":"Space"},{"t":"Str","c":"účinnost"},{"t":"Space"},{"t":"Str","c":"experimentálně"},{"t":"Space"},{"t":"Str","c":"(což"},{"t":"Space"},{"t":"Str","c":"vyloučí"},{"t":"Space"},{"t":"Str","c":"případné"},{"t":"Space"},{"t":"Str","c":"diskuse"},{"t":"Space"},{"t":"Str","c":"o"},{"t":"Space"},{"t":"Str","c":"jejich"},{"t":"SoftBreak"},{"t":"Str","c":"vhodnosti)."}]},{"t":"Para","c":[{"t":"Str","c":"Zpráva"},{"t":"Space"},{"t":"Str","c":"by"},{"t":"Space"},{"t":"Str","c":"měla"},{"t":"Space"},{"t":"Str","c":"dokládat"},{"t":"Space"},{"t":"Str","c":"Váš"},{"t":"Space"},{"t":"Str","c":"racionální"},{"t":"Space"},{"t":"Str","c":"přístup"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"řešení"},{"t":"Space"},{"t":"Str","c":"problému,"},{"t":"Space"},{"t":"Str","c":"tedy"},{"t":"Space"},{"t":"Str","c":"celý"},{"t":"SoftBreak"},{"t":"Str","c":"pracovní"},{"t":"Space"},{"t":"Str","c":"postup."},{"t":"Space"},{"t":"Str","c":"Ve"},{"t":"Space"},{"t":"Str","c":"zprávě"},{"t":"Space"},{"t":"Str","c":"prosím"},{"t":"Space"},{"t":"Str","c":"také"},{"t":"Space"},{"t":"Str","c":"popište"},{"t":"Space"},{"t":"Str","c":"obě"},{"t":"Space"},{"t":"Str","c":"fáze"},{"t":"Space"},{"t":"Str","c":"nasazení"},{"t":"Space"},{"t":"Str","c":"heuristiky,"},{"t":"Space"},{"t":"Str","c":"jak"},{"t":"SoftBreak"},{"t":"Str","c":"nastavení,"},{"t":"Space"},{"t":"Str","c":"(white"},{"t":"Space"},{"t":"Str","c":"box"},{"t":"Space"},{"t":"Str","c":"fáze),"},{"t":"Space"},{"t":"Str","c":"tak"},{"t":"Space"},{"t":"Str","c":"závěrečné"},{"t":"Space"},{"t":"Str","c":"vyhodnocení"},{"t":"Space"},{"t":"Str","c":"heuristiky"},{"t":"Space"},{"t":"Str","c":"(black"},{"t":"Space"},{"t":"Str","c":"box"},{"t":"SoftBreak"},{"t":"Str","c":"fáze)."},{"t":"Space"},{"t":"Str","c":"Prosím"},{"t":"Space"},{"t":"Str","c":"používejte"},{"t":"Space"},{"t":"Str","c":"definované"},{"t":"Space"},{"t":"Str","c":"formáty"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"instance"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"řešení,"},{"t":"Space"},{"t":"Str","c":"usnadníte"},{"t":"Space"},{"t":"Str","c":"tak"},{"t":"SoftBreak"},{"t":"Str","c":"lepší"},{"t":"Space"},{"t":"Str","c":"přizpůsobení"},{"t":"Space"},{"t":"Str","c":"zkušebních"},{"t":"Space"},{"t":"Str","c":"instancí."}]},{"t":"Header","c":[3,["hodnocení",[],[]],[{"t":"Str","c":"Hodnocení"}]]},{"t":"Para","c":[{"t":"Str","c":"Tato"},{"t":"Space"},{"t":"Str","c":"úloha"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"součástí"},{"t":"Space"},{"t":"Str","c":"hodnocení"},{"t":"Space"},{"t":"Str","c":"zkoušky"},{"t":"Space"},{"t":"Str","c":"-"},{"t":"Space"},{"t":"Str","c":"až"},{"t":"Space"},{"t":"Str","c":"30"},{"t":"Space"},{"t":"Str","c":"bodů"},{"t":"Space"},{"t":"Str","c":"ze"},{"t":"Space"},{"t":"Str","c":"100"},{"t":"Space"},{"t":"Str","c":"za"},{"t":"Space"},{"t":"Str","c":"předmět"},{"t":"Space"},{"t":"Str","c":"celkem."},{"t":"SoftBreak"},{"t":"Str","c":"Práce"},{"t":"Space"},{"t":"Str","c":"by"},{"t":"Space"},{"t":"Str","c":"měla"},{"t":"Space"},{"t":"Str","c":"doložit"},{"t":"Space"},{"t":"Str","c":"Vaši"},{"t":"Space"},{"t":"Str","c":"schopnost"},{"t":"Space"},{"t":"Str","c":"nasadit"},{"t":"Space"},{"t":"Str","c":"pokročilé"},{"t":"Space"},{"t":"Str","c":"heuristiky"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"netriviální"},{"t":"SoftBreak"},{"t":"Str","c":"optimalizační"},{"t":"Space"},{"t":"Str","c":"problém."},{"t":"Space"},{"t":"Str","c":"Nasazená"},{"t":"Space"},{"t":"Str","c":"heuristika"},{"t":"Space"},{"t":"Str","c":"by"},{"t":"Space"},{"t":"Str","c":"měla"},{"t":"Space"},{"t":"Str","c":"zpracovávat"},{"t":"Space"},{"t":"Str","c":"rozumně"},{"t":"Space"},{"t":"Str","c":"široké"},{"t":"SoftBreak"},{"t":"Str","c":"spektrum"},{"t":"Space"},{"t":"Str","c":"instancí"},{"t":"Space"},{"t":"Str","c":"s"},{"t":"Space"},{"t":"Str","c":"rozumnou"},{"t":"Space"},{"t":"Str","c":"chybou."},{"t":"Space"},{"t":"Str","c":"Co"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"rozumně"}]]},{"t":"Str","c":","},{"t":"Space"},{"t":"Str","c":"bychom"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"měli"},{"t":"Space"},{"t":"Str","c":"dočíst"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"SoftBreak"},{"t":"Str","c":"závěru"},{"t":"Space"},{"t":"Str","c":"Vaší"},{"t":"Space"},{"t":"Str","c":"práce."}]},{"t":"Para","c":[{"t":"Str","c":"V"},{"t":"Space"},{"t":"Str","c":"hodnocení"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"kladen"},{"t":"Space"},{"t":"Str","c":"důraz"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"racionální"},{"t":"Space"},{"t":"Str","c":"postup"},{"t":"Space"},{"t":"Str","c":"celé"},{"t":"Space"},{"t":"Str","c":"práce."},{"t":"Space"},{"t":"Str","c":"Pokud"},{"t":"Space"},{"t":"Str","c":"postup"},{"t":"SoftBreak"},{"t":"Str","c":"vyhovuje,"},{"t":"Space"},{"t":"Str","c":"méně"},{"t":"Space"},{"t":"Str","c":"uspokojivé"},{"t":"Space"},{"t":"Str","c":"výsledky"},{"t":"Space"},{"t":"Str","c":"heuristiky"},{"t":"Space"},{"t":"Str","c":"příliš"},{"t":"Space"},{"t":"Str","c":"nevadí,"},{"t":"Space"},{"t":"Str","c":"vzhledem"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"tomu,"},{"t":"Space"},{"t":"Str","c":"že"},{"t":"SoftBreak"},{"t":"Str","c":"řešený"},{"t":"Space"},{"t":"Str","c":"problém"},{"t":"Space"},{"t":"Str","c":"(jak"},{"t":"Space"},{"t":"Str","c":"jistě"},{"t":"Space"},{"t":"Str","c":"víte)"},{"t":"Space"},{"t":"Str","c":"patří"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"nejtěžším"},{"t":"Space"},{"t":"Str","c":"ve"},{"t":"Space"},{"t":"Str","c":"třídě"},{"t":"Space"},{"t":"Str","c":"NPO."},{"t":"Space"},{"t":"Str","c":"Proto"},{"t":"SoftBreak"},{"t":"Str","c":"potřebujeme"},{"t":"Space"},{"t":"Str","c":"znát"},{"t":"Space"},{"t":"Str","c":"jak"},{"t":"Space"},{"t":"Str","c":"pracovní"},{"t":"Space"},{"t":"Str","c":"postup"},{"t":"Space"},{"t":"Str","c":"ve"},{"t":"Space"},{"t":"Str","c":"white"},{"t":"Space"},{"t":"Str","c":"box"},{"t":"Space"},{"t":"Str","c":"fázi,"},{"t":"Space"},{"t":"Str","c":"tak"},{"t":"Space"},{"t":"Str","c":"výsledky"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"závěr"},{"t":"SoftBreak"},{"t":"Str","c":"black"},{"t":"Space"},{"t":"Str","c":"box"},{"t":"Space"},{"t":"Str","c":"fáze."}]},{"t":"Para","c":[{"t":"Str","c":"Hodnocení"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"rozděleno"},{"t":"Space"},{"t":"Str","c":"do"},{"t":"Space"},{"t":"Str","c":"tří"},{"t":"Space"},{"t":"Str","c":"kategorií:"}]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Str","c":"Algoritmus"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"implementace"},{"t":"Space"},{"t":"Str","c":"(5"},{"t":"Space"},{"t":"Str","c":"pt.)"}]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Str","c":"Byly"},{"t":"Space"},{"t":"Str","c":"použity"},{"t":"Space"},{"t":"Str","c":"techniky"},{"t":"Space"},{"t":"Str","c":"(algoritmy,"},{"t":"Space"},{"t":"Str","c":"datové"},{"t":"Space"},{"t":"Str","c":"struktury)"},{"t":"Space"},{"t":"Str","c":"adekvátní"},{"t":"Space"},{"t":"Str","c":"problému?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Byly"},{"t":"Space"},{"t":"Str","c":"použity"},{"t":"Space"},{"t":"Str","c":"pokročilé"},{"t":"Space"},{"t":"Str","c":"techniky?"},{"t":"Space"},{"t":"Str","c":"(např."},{"t":"Space"},{"t":"Str","c":"adaptační"},{"t":"Space"},{"t":"Str","c":"mechanismy)"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Jsou"},{"t":"Space"},{"t":"Str","c":"některé"},{"t":"Space"},{"t":"Str","c":"postupy"},{"t":"Space"},{"t":"Str","c":"originálním"},{"t":"Space"},{"t":"Str","c":"přínosem"},{"t":"Space"},{"t":"Str","c":"autora?"}]}]]}],[{"t":"Plain","c":[{"t":"Str","c":"Nastavení"},{"t":"Space"},{"t":"Str","c":"heuristiky"},{"t":"Space"},{"t":"Str","c":"(13"},{"t":"Space"},{"t":"Str","c":"pt.)"}]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Str","c":"Jakou"},{"t":"Space"},{"t":"Str","c":"metodou"},{"t":"Space"},{"t":"Str","c":"autor"},{"t":"Space"},{"t":"Str","c":"hledal"},{"t":"Space"},{"t":"Str","c":"nastavení"},{"t":"Space"},{"t":"Str","c":"parametrů?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Jak"},{"t":"Space"},{"t":"Str","c":"byly"},{"t":"Space"},{"t":"Str","c":"plánovány"},{"t":"Space"},{"t":"Str","c":"experimenty"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"jaké"},{"t":"Space"},{"t":"Str","c":"byly"},{"t":"Space"},{"t":"Str","c":"jejich"},{"t":"Space"},{"t":"Str","c":"otázky?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Jestliže"},{"t":"Space"},{"t":"Str","c":"byl"},{"t":"Space"},{"t":"Str","c":"proveden"},{"t":"Space"},{"t":"Str","c":"faktorový"},{"t":"Space"},{"t":"Str","c":"návrh"},{"t":"Space"},{"t":"Str","c":"(což"},{"t":"Space"},{"t":"Str","c":"příliš"},{"t":"Space"},{"t":"Str","c":"nedoporučujeme),"},{"t":"Space"},{"t":"Str","c":"jak"},{"t":"SoftBreak"},{"t":"Str","c":"kompletní"},{"t":"Space"},{"t":"Str","c":"byl"},{"t":"Space"},{"t":"Str","c":"(změna"},{"t":"Space"},{"t":"Str","c":"vždy"},{"t":"Space"},{"t":"Str","c":"jen"},{"t":"Space"},{"t":"Str","c":"jednoho"},{"t":"Space"},{"t":"Str","c":"parametru"},{"t":"Space"},{"t":"Str","c":"nestačí)?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Na"},{"t":"Space"},{"t":"Str","c":"jak"},{"t":"Space"},{"t":"Str","c":"velkých"},{"t":"Space"},{"t":"Str","c":"instancích"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"heuristika"},{"t":"Space"},{"t":"Str","c":"schopna"},{"t":"Space"},{"t":"Str","c":"pracovat?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Jestliže"},{"t":"Space"},{"t":"Str","c":"práce"},{"t":"Space"},{"t":"Str","c":"heuristiky"},{"t":"Space"},{"t":"Str","c":"není"},{"t":"Space"},{"t":"Str","c":"uspokojivá,"},{"t":"Space"},{"t":"Str","c":"jak"},{"t":"Space"},{"t":"Str","c":"systematické"},{"t":"Space"},{"t":"Str","c":"byly"},{"t":"Space"},{"t":"Str","c":"snahy"},{"t":"SoftBreak"},{"t":"Str","c":"autora"},{"t":"Space"},{"t":"Str","c":"zjednat"},{"t":"Space"},{"t":"Str","c":"nápravu?"}]}]]}],[{"t":"Plain","c":[{"t":"Str","c":"Experimentální"},{"t":"Space"},{"t":"Str","c":"vyhodnocení"},{"t":"Space"},{"t":"Str","c":"heuristiky"},{"t":"Space"},{"t":"Str","c":"(12"},{"t":"Space"},{"t":"Str","c":"pt.)"}]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Str","c":"Jak"},{"t":"Space"},{"t":"Str","c":"dalece"},{"t":"Space"},{"t":"Str","c":"jsou"},{"t":"Space"},{"t":"Str","c":"závěry"},{"t":"Space"},{"t":"Str","c":"vyhodnocení"},{"t":"Space"},{"t":"Str","c":"doloženy"},{"t":"Space"},{"t":"Str","c":"experimentálně?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Je"},{"t":"Space"},{"t":"Str","c":"interpretace"},{"t":"Space"},{"t":"Str","c":"experimentů"},{"t":"Space"},{"t":"Str","c":"přesvědčivá?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Pokud"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"algoritmus"},{"t":"Space"},{"t":"Str","c":"randomizovaný,"},{"t":"Space"},{"t":"Str","c":"byla"},{"t":"Space"},{"t":"Str","c":"tato"},{"t":"Space"},{"t":"Str","c":"skutečnost"},{"t":"Space"},{"t":"Str","c":"vzata"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"úvahu"},{"t":"Space"},{"t":"Str","c":"při"},{"t":"SoftBreak"},{"t":"Str","c":"plánování"},{"t":"Space"},{"t":"Str","c":"experimentů?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Je"},{"t":"Space"},{"t":"Str","c":"možno"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Str","c":"experimentů"},{"t":"Space"},{"t":"Str","c":"usoudit"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"iterativní"},{"t":"Space"},{"t":"Str","c":"sílu"},{"t":"Space"},{"t":"Str","c":"heuristiky?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Byly"},{"t":"Space"},{"t":"Str","c":"nestandardní"},{"t":"Space"},{"t":"Str","c":"postupy"},{"t":"Space"},{"t":"Str","c":"experimentálně"},{"t":"Space"},{"t":"Str","c":"porovnány"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"standardními?"}]}],[{"t":"Plain","c":[{"t":"Str","c":"Jsou"},{"t":"Space"},{"t":"Str","c":"výsledky"},{"t":"Space"},{"t":"Str","c":"experimentů"},{"t":"Space"},{"t":"Str","c":"srozumitelně"},{"t":"Space"},{"t":"Str","c":"prezentovány"},{"t":"Space"},{"t":"Str","c":"(grafy,"},{"t":"Space"},{"t":"Str","c":"tabulky,"},{"t":"SoftBreak"},{"t":"Str","c":"statistické"},{"t":"Space"},{"t":"Str","c":"metody)?"}]}]]}]]},{"t":"Para","c":[{"t":"Str","c":"Práce"},{"t":"Space"},{"t":"Str","c":"bez"},{"t":"Space"},{"t":"Str","c":"experimentální"},{"t":"Space"},{"t":"Str","c":"části"},{"t":"Space"},{"t":"Str","c":"nemůže"},{"t":"Space"},{"t":"Str","c":"být"},{"t":"Space"},{"t":"Str","c":"přijata"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"hodnocení."}]},{"t":"Header","c":[3,["instance",[],[]],[{"t":"Str","c":"Instance"}]]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Str","c":"SAT"},{"t":"Space"},{"t":"Str","c":"instance"},{"t":"Space"},{"t":"Str","c":"lze"},{"t":"Space"},{"t":"Str","c":"generovat"},{"t":"Space"},{"t":"Str","c":"náhodně."},{"t":"Space"},{"t":"Str","c":"Klíčovým"},{"t":"Space"},{"t":"Str","c":"parametrem"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"poměr"},{"t":"Space"},{"t":"Str","c":"počtu"},{"t":"SoftBreak"},{"t":"Str","c":"klauzulí"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"počtu"},{"t":"Space"},{"t":"Str","c":"proměnných"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"3-SAT"},{"t":"Space"},{"t":"Str","c":"(viz"},{"t":"Space"},{"t":"Str","c":"ai-phys1.pdf"},{"t":"Space"},{"t":"Str","c":"-"},{"t":"Space"},{"t":"Str","c":"doporučujeme)."},{"t":"Space"},{"t":"Str","c":"Váhy"},{"t":"SoftBreak"},{"t":"Str","c":"lze"},{"t":"Space"},{"t":"Str","c":"generovat"},{"t":"Space"},{"t":"Str","c":"náhodně."},{"t":"Space"},{"t":"Str","c":"V"},{"t":"Space"},{"t":"Str","c":"takovém"},{"t":"Space"},{"t":"Str","c":"případě"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"vhodné"},{"t":"Space"},{"t":"Str","c":"prokázat,"},{"t":"Space"},{"t":"Str","c":"že"},{"t":"Space"},{"t":"Str","c":"instance,"},{"t":"Space"},{"t":"Str","c":"kde"},{"t":"SoftBreak"},{"t":"Str","c":"všechny"},{"t":"Space"},{"t":"Str","c":"váhy"},{"t":"Space"},{"t":"Str","c":"byly"},{"t":"Space"},{"t":"Str","c":"vynásobeny"},{"t":"Space"},{"t":"Str","c":"velkým"},{"t":"Space"},{"t":"Str","c":"číslem,"},{"t":"Space"},{"t":"Str","c":"jsou"},{"t":"Space"},{"t":"Str","c":"zpracovávány"},{"t":"Space"},{"t":"Str","c":"stejně"},{"t":"Space"},{"t":"Str","c":"úspěšně."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Lze"},{"t":"Space"},{"t":"Str","c":"vyjít"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"DIMACS"}],["http://www.cs.ubc.ca/~hoos/SATLIB/benchm.html",""]]},{"t":"Space"},{"t":"Str","c":"SAT"},{"t":"SoftBreak"},{"t":"Str","c":"instancí."},{"t":"Space"},{"t":"Str","c":"Nemají"},{"t":"Space"},{"t":"Str","c":"váhy,"},{"t":"Space"},{"t":"Str","c":"jejich"},{"t":"Space"},{"t":"Str","c":"generování"},{"t":"Space"},{"t":"Str","c":"viz"},{"t":"Space"},{"t":"Str","c":"výše.Tyto"},{"t":"Space"},{"t":"Str","c":"instance"},{"t":"Space"},{"t":"Str","c":"jsou"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"hraně"},{"t":"SoftBreak"},{"t":"Str","c":"fázového"},{"t":"Space"},{"t":"Str","c":"přechodu,"},{"t":"Space"},{"t":"Str","c":"jsou"},{"t":"Space"},{"t":"Str","c":"tedy"},{"t":"Space"},{"t":"Str","c":"značně"},{"t":"Space"},{"t":"Str","c":"obtížné."},{"t":"Space"},{"t":"Str","c":"Obtížnost"},{"t":"Space"},{"t":"Str","c":"můžete"},{"t":"Space"},{"t":"Str","c":"snížit"},{"t":"Space"},{"t":"Str","c":"zkrácením"},{"t":"SoftBreak"},{"t":"Str","c":"(vynechání"},{"t":"Space"},{"t":"Str","c":"klauzulí)."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Připravili"},{"t":"Space"},{"t":"Str","c":"jsme"},{"t":"Space"},{"t":"Str","c":"sady"},{"t":"Space"},{"t":"Str","c":"zkušebních"},{"t":"Space"},{"t":"Str","c":"instancí."},{"t":"Space"},{"t":"Str","c":"Vycházejí"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Str","c":"instancí"},{"t":"Space"},{"t":"Str","c":"SATLIB,"},{"t":"Space"},{"t":"Str","c":"jsou"},{"t":"SoftBreak"},{"t":"Str","c":"ale"},{"t":"Space"},{"t":"Str","c":"zkráceny"},{"t":"Space"},{"t":"Str","c":"tak,"},{"t":"Space"},{"t":"Str","c":"aby"},{"t":"Space"},{"t":"Str","c":"měly"},{"t":"Space"},{"t":"Str","c":"co"},{"t":"Space"},{"t":"Str","c":"nejvíce"},{"t":"Space"},{"t":"Str","c":"řešení"},{"t":"Space"},{"t":"Str","c":"(počty"},{"t":"Space"},{"t":"Str","c":"řešení"},{"t":"Space"},{"t":"Str","c":"přikládáme)."},{"t":"Space"},{"t":"Str","c":"Váhy"},{"t":"SoftBreak"},{"t":"Str","c":"nejsou"},{"t":"Space"},{"t":"Str","c":"náhodné,"},{"t":"Space"},{"t":"Str","c":"mají"},{"t":"Space"},{"t":"Str","c":"ale"},{"t":"Space"},{"t":"Str","c":"náhodnou"},{"t":"Space"},{"t":"Str","c":"složku."},{"t":"Space"},{"t":"Str","c":"Za"},{"t":"Space"},{"t":"Str","c":"upozornění"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"chyby,"},{"t":"SoftBreak"},{"t":"Str","c":"nekonzistence"},{"t":"Space"},{"t":"Str","c":"atd."},{"t":"Space"},{"t":"Str","c":"budeme"},{"t":"Space"},{"t":"Str","c":"vděčni."}]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Code","c":[["",[],[]],"wuf-M"]},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"wuf-N"]},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"Váhy"},{"t":"Space"},{"t":"Str","c":"by"},{"t":"Space"},{"t":"Str","c":"měly"},{"t":"Space"},{"t":"Str","c":"podporovat"},{"t":"Space"},{"t":"Str","c":"nalezení"},{"t":"Space"},{"t":"Str","c":"řešení."},{"t":"Space"},{"t":"Str","c":"Heuristika,"},{"t":"SoftBreak"},{"t":"Str","c":"která"},{"t":"Space"},{"t":"Str","c":"řeší"},{"t":"Space"},{"t":"Str","c":"určitou"},{"t":"Space"},{"t":"Str","c":"instanci"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"sadě"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"wuf-M"]},{"t":"Str","c":","},{"t":"Space"},{"t":"Str","c":"by"},{"t":"Space"},{"t":"Str","c":"měla"},{"t":"Space"},{"t":"Str","c":"řešit"},{"t":"Space"},{"t":"Str","c":"odpovídající"},{"t":"SoftBreak"},{"t":"Str","c":"instanci"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"sadě"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"wuf-N"]},{"t":"Space"},{"t":"Str","c":"stejně"},{"t":"Space"},{"t":"Str","c":"snadno."},{"t":"Space"},{"t":"Str","c":"Vzhledem"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"počtu"},{"t":"Space"},{"t":"Str","c":"řešení"},{"t":"Space"},{"t":"Str","c":"jednotlivých"},{"t":"SoftBreak"},{"t":"Str","c":"instací"},{"t":"Space"},{"t":"Str","c":"(až"},{"t":"Space"},{"t":"Str","c":"108),"},{"t":"Space"},{"t":"Str","c":"není"},{"t":"Space"},{"t":"Str","c":"možné"},{"t":"Space"},{"t":"Str","c":"efektivně"},{"t":"Space"},{"t":"Str","c":"najít"},{"t":"Space"},{"t":"Str","c":"optimální"},{"t":"Space"},{"t":"Str","c":"řešení"}]}],[{"t":"Plain","c":[{"t":"Code","c":[["",[],[]],"wuf-Q"]},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"wuf-R"]},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"Jako"},{"t":"Space"},{"t":"Str","c":"výše,"},{"t":"Space"},{"t":"Str","c":"váhy"},{"t":"Space"},{"t":"Str","c":"ale"},{"t":"Space"},{"t":"Str","c":"vytvářejí"},{"t":"Space"},{"t":"Str","c":"(mírně)"},{"t":"Space"},{"t":"Str","c":"zavádějící"},{"t":"Space"},{"t":"Str","c":"úlohu."}]}],[{"t":"Plain","c":[{"t":"Code","c":[["",[],[]],"wuf-A"]},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Str","c":"dílny"},{"t":"Space"},{"t":"Str","c":"prof."},{"t":"Space"},{"t":"Str","c":"Zlomyslného."},{"t":"Space"},{"t":"Str","c":"Instance"},{"t":"Space"},{"t":"Str","c":"vycházejí"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Str","c":"nezkrácených"},{"t":"Space"},{"t":"Str","c":"(nebo"},{"t":"SoftBreak"},{"t":"Str","c":"jen"},{"t":"Space"},{"t":"Str","c":"mírně"},{"t":"Space"},{"t":"Str","c":"zkrácených)"},{"t":"Space"},{"t":"Str","c":"instancí,"},{"t":"Space"},{"t":"Str","c":"takže"},{"t":"Space"},{"t":"Str","c":"jsou"},{"t":"Space"},{"t":"Str","c":"obtížné."},{"t":"Space"},{"t":"Str","c":"Váhy"},{"t":"Space"},{"t":"Str","c":"vytvářejí"},{"t":"SoftBreak"},{"t":"Str","c":"zavádějící"},{"t":"Space"},{"t":"Str","c":"úlohu."},{"t":"Space"},{"t":"Str","c":"Nicméně,"},{"t":"Space"},{"t":"Str","c":"malý"},{"t":"Space"},{"t":"Str","c":"počet"},{"t":"Space"},{"t":"Str","c":"řešení"},{"t":"Space"},{"t":"Str","c":"dovoluje"},{"t":"Space"},{"t":"Str","c":"ve"},{"t":"Space"},{"t":"Str","c":"většině"},{"t":"Space"},{"t":"Str","c":"případů"},{"t":"SoftBreak"},{"t":"Str","c":"uvést"},{"t":"Space"},{"t":"Str","c":"optimální"},{"t":"Space"},{"t":"Str","c":"řešení."}]}]]}]]},{"t":"Header","c":[2,["řešení",[],[]],[{"t":"Str","c":"Řešení"}]]},{"t":"Para","c":[{"t":"Str","c":"Úkoly"},{"t":"Space"},{"t":"Str","c":"předmětu"},{"t":"Space"},{"t":"Str","c":"NI-KOP"},{"t":"Space"},{"t":"Str","c":"jsem"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"rozhodl"},{"t":"Space"},{"t":"Str","c":"implementovat"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"jazyce"},{"t":"Space"},{"t":"Str","c":"Rust"},{"t":"Space"},{"t":"Str","c":"za"},{"t":"Space"},{"t":"Str","c":"pomoci"},{"t":"SoftBreak"},{"t":"Str","c":"nástrojů"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Emph","c":[{"t":"Str","c":"literate"},{"t":"Space"},{"t":"Str","c":"programming"}]},{"t":"Space"},{"t":"Str","c":"–"},{"t":"Space"},{"t":"Str","c":"přístup"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"psaní"},{"t":"Space"},{"t":"Str","c":"zdrojového"},{"t":"Space"},{"t":"Str","c":"kódu,"},{"t":"Space"},{"t":"Str","c":"který"},{"t":"SoftBreak"},{"t":"Str","c":"upřednostňuje"},{"t":"Space"},{"t":"Str","c":"lidsky"},{"t":"Space"},{"t":"Str","c":"čitelný"},{"t":"Space"},{"t":"Str","c":"popis"},{"t":"Space"},{"t":"Str","c":"před"},{"t":"Space"},{"t":"Str","c":"seznamem"},{"t":"Space"},{"t":"Str","c":"příkazů"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"počítač."},{"t":"Space"},{"t":"Str","c":"Tento"},{"t":"SoftBreak"},{"t":"Str","c":"dokument"},{"t":"Space"},{"t":"Str","c":"obsahuje"},{"t":"Space"},{"t":"Str","c":"veškerý"},{"t":"Space"},{"t":"Str","c":"zdrojový"},{"t":"Space"},{"t":"Str","c":"kód"},{"t":"Space"},{"t":"Str","c":"nutný"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"reprodukci"},{"t":"Space"},{"t":"Str","c":"mojí"},{"t":"Space"},{"t":"Str","c":"práce."},{"t":"Space"},{"t":"Str","c":"Výsledek"},{"t":"SoftBreak"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"dostupný"},{"t":"Space"},{"t":"Str","c":"online"},{"t":"Space"},{"t":"Str","c":"jako"},{"t":"Space"},{"t":"Str","c":"statická"},{"t":"Space"},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"webová"},{"t":"Space"},{"t":"Str","c":"stránka"}],["http://viluon.me/ni-kop/",""]]},{"t":"Space"},{"t":"Str","c":"a"},{"t":"SoftBreak"},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"ke"},{"t":"Space"},{"t":"Str","c":"stažení"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"PDF"}],["http://viluon.me/ni-kop/report.pdf",""]]},{"t":"Str","c":"."}]},{"t":"Header","c":[2,["instrukce-k-sestavení-programu",[],[]],[{"t":"Str","c":"Instrukce"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"sestavení"},{"t":"Space"},{"t":"Str","c":"programu"}]]},{"t":"Para","c":[{"t":"Str","c":"Program"},{"t":"Space"},{"t":"Str","c":"využívá"},{"t":"Space"},{"t":"Str","c":"standardních"},{"t":"Space"},{"t":"Str","c":"nástrojů"},{"t":"Space"},{"t":"Str","c":"jazyka"},{"t":"Space"},{"t":"Str","c":"Rust."},{"t":"Space"},{"t":"Str","c":"O"},{"t":"Space"},{"t":"Str","c":"sestavení"},{"t":"Space"},{"t":"Str","c":"stačí"},{"t":"Space"},{"t":"Str","c":"požádat"},{"t":"SoftBreak"},{"t":"Code","c":[["",[],[]],"cargo"]},{"t":"Str","c":"."}]},{"t":"Div","c":[["",["doctest"],[["status","SUCCESS"]]],[{"t":"Div","c":[["",["doctestInput"],[]],[{"t":"CodeBlock","c":[["build-instructions",["zsh","eval","bootstrap-fold"],[]],"cd solver\ncargo build --release --color always"]}]]},{"t":"Div","c":[["",["doctestResult"],[]],[{"t":"Div","c":[["",["programOutput"],[]],[{"t":"RawBlock","c":["html","<pre class=\"ansi2html-content\">info: syncing channel updates for 'nightly-x86_64-unknown-linux-gnu'\r\ninfo: latest update on 2022-01-27, rust version 1.60.0-nightly (6abb6385b 2022-01-26)\r\ninfo: downloading component 'cargo'\r\ninfo: downloading component 'rust-std'\r\ninfo: downloading component 'rustc'\r\ninfo: installing component 'cargo'\r\ninfo: installing component 'rust-std'\r\ninfo: installing component 'rustc'\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">    Updating</span> crates.io index\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\"> Downloading</span> crates ...\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> itoa v1.0.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> log v0.4.14\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> memoffset v0.6.4\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> arrayvec v0.7.2\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> crossbeam-channel v0.5.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> bitvec v0.22.3\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> serde_json v1.0.78\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> scopeguard v1.1.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> num_cpus v1.13.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> rayon-core v1.9.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> rand_xoshiro v0.6.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> rayon v1.5.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> radium v0.6.2\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> tap v1.0.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> quickcheck v1.0.3\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> crossbeam-deque v0.8.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> wyz v0.4.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> syn v1.0.80\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> funty v1.2.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> env_logger v0.8.4\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> crossbeam-epoch v0.9.5\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> anyhow v1.0.44\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> libc v0.2.103\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> crossbeam-utils v0.8.5\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> aho-corasick v0.7.18\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> either v1.6.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> proc-macro2 v1.0.29\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> quickcheck_macros v1.0.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">  Downloaded</span> permutation v0.2.5\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> cfg-if v1.0.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> libc v0.2.103\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> autocfg v1.0.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> proc-macro2 v1.0.29\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> unicode-xid v0.2.2\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> crossbeam-utils v0.8.5\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> syn v1.0.80\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> memchr v2.4.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> lazy_static v1.4.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> crossbeam-epoch v0.9.5\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> scopeguard v1.1.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> rayon-core v1.9.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> log v0.4.14\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> serde_derive v1.0.130\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> ppv-lite86 v0.2.15\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> serde v1.0.130\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> radium v0.6.2\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> ryu v1.0.5\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> regex-syntax v0.6.25\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> serde_json v1.0.78\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> tap v1.0.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> anyhow v1.0.44\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> itoa v1.0.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> funty v1.2.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> either v1.6.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> arrayvec v0.7.2\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> permutation v0.2.5\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> memoffset v0.6.4\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> rayon v1.5.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> wyz v0.4.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> getrandom v0.2.3\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> num_cpus v1.13.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> quote v1.0.10\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> crossbeam-channel v0.5.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> aho-corasick v0.7.18\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> bitvec v0.22.3\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> rand_core v0.6.3\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> regex v1.5.4\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> crossbeam-deque v0.8.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> rand_chacha v0.3.1\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> rand_xoshiro v0.6.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> env_logger v0.8.4\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> quickcheck_macros v1.0.0\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> rand v0.8.4\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> quickcheck v1.0.3\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">   Compiling</span> solver v0.1.0 (/__w/ni-kop/ni-kop/5-weighted-sat/solver)\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #00aa00\">    Finished</span> release [optimized + debuginfo] target(s) in 1m 48s\r\n</pre>"]}]]}]]}]]},{"t":"Header","c":[2,["benchmarking",[],[]],[{"t":"Str","c":"Benchmarking"}]]},{"t":"Para","c":[{"t":"Str","c":"Stejně"},{"t":"Space"},{"t":"Str","c":"jako"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"předchozí"},{"t":"Space"},{"t":"Str","c":"úloze"},{"t":"Space"},{"t":"Str","c":"jsem"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"ani"},{"t":"Space"},{"t":"Str","c":"tentokrát"},{"t":"Space"},{"t":"Str","c":"s"},{"t":"Space"},{"t":"Str","c":"měřením"},{"t":"Space"},{"t":"Str","c":"výkonu"},{"t":"Space"},{"t":"Str","c":"nespoléhal"},{"t":"SoftBreak"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"existující"},{"t":"Space"},{"t":"Str","c":"Rust"},{"t":"Space"},{"t":"Str","c":"knihovny"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"namísto"},{"t":"Space"},{"t":"Str","c":"toho"},{"t":"Space"},{"t":"Str","c":"provedl"},{"t":"Space"},{"t":"Str","c":"měření"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"Pythonu."}]},{"t":"Div","c":[["",["doctest"],[["status","SUCCESS"]]],[{"t":"Div","c":[["",["doctestInput"],[]],[{"t":"CodeBlock","c":[["machine-info",["zsh","eval","bootstrap-fold"],[]],"uname -a\n./cpufetch --logo-short --color ibm"]}]]},{"t":"Div","c":[["",["doctestResult"],[]],[{"t":"Div","c":[["",["programOutput"],[]],[{"t":"RawBlock","c":["html","<pre class=\"ansi2html-content\">Linux 0e15fe81eee5 5.11.0-1027-azure #30~20.04.1-Ubuntu SMP Wed Jan 12 20:56:50 UTC 2022 x86_64 GNU/Linux\r\n\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">                   .#################.          </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">Name:</span>       <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">Intel Xeon Platinum </span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">              .####                   ####.     </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">Hypervisor:</span> <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">Microsoft Hyper-V</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">          .##                             ###   </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">uArch:</span>      <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">Cascade Lake</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">       ##                          :##     ###  </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">Technology:</span> <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">14nm</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">    #                ##            :##      ##  </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">Max Freq:</span>   <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">Unknown</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">  ##   ##  ######.   ####  ######  :##      ##  </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">Cores:</span>      <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">2 cores</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\"> ##    ##  ##:  ##:  ##   ##   ### :##     ###  </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">AVX:</span>        <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">AVX,AVX2,AVX512</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">##     ##  ##:  ##:  ##  :######## :##    ##    </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">FMA:</span>        <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">FMA3</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">##     ##  ##:  ##:  ##   ##.   .  :## ####     </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">L1i Size:</span>   <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">32KB (64KB Total)</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">##      #  ##:  ##:  ####  #####:   ##          </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">L1d Size:</span>   <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">32KB (64KB Total)</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\"> ##                                             </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">L2 Size:</span>    <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">1MB (2MB Total)</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">  ###.                         ..o####.         </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">L3 Size:</span>    <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">35.75MB</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">   ######oo...         ..oo#######              </span><span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #585858\">Peak Perf.:</span> <span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">Unknown</span>\r\n<span style=\"font-weight: bold\"></span><span style=\"font-weight: bold; color: #8700d7\">          o###############o                     </span>\r\n\r\n</pre>"]}]]}]]}]]},{"t":"Header","c":[3,["white-box-průzkum-chování-algoritmu",[],[]],[{"t":"Str","c":"White"},{"t":"Space"},{"t":"Str","c":"box:"},{"t":"Space"},{"t":"Str","c":"průzkum"},{"t":"Space"},{"t":"Str","c":"chování"},{"t":"Space"},{"t":"Str","c":"algoritmu"}]]},{"t":"Para","c":[{"t":"Str","c":"Následující"},{"t":"Space"},{"t":"Str","c":"soubor"},{"t":"Space"},{"t":"Str","c":"slouží"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"vyhodnocení"},{"t":"Space"},{"t":"Str","c":"algoritmu"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"různých"},{"t":"Space"},{"t":"Str","c":"datových"},{"t":"Space"},{"t":"Str","c":"sadách"},{"t":"Space"},{"t":"Str","c":"s"},{"t":"SoftBreak"},{"t":"Str","c":"různými"},{"t":"Space"},{"t":"Str","c":"parametry."},{"t":"Space"},{"t":"Str","c":"Spouští"},{"t":"Space"},{"t":"Str","c":"implementaci"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"jazyce"},{"t":"Space"},{"t":"Str","c":"Rust"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"výsledky"},{"t":"Space"},{"t":"Str","c":"měření"},{"t":"Space"},{"t":"Str","c":"ukládá"},{"t":"SoftBreak"},{"t":"Str","c":"do"},{"t":"Space"},{"t":"Str","c":"binárního"},{"t":"Space"},{"t":"Str","c":"souboru"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"následnou"},{"t":"Space"},{"t":"Str","c":"analýzu."}]},{"t":"CodeBlock","c":[["",["python","bootstrap-fold"],[["file","analysis/measure.py"]]],"import os\nfrom itertools import product, chain\nfrom subprocess import run, PIPE\nimport json\nimport pandas as pd\n\nshow_progress = os.environ.get(\"JUPYTER\") == None\n\n# adapted from https://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console\ndef progress_bar(iteration, total, length = 60):\n    if not show_progress:\n        return\n    percent = (\"{0:.1f}\").format(100 * (iteration / float(total)))\n    filledLength = int(length * iteration // total)\n    bar = '=' * filledLength + ' ' * (length - filledLength)\n    print(f'\\r[{bar}] {percent}%', end = \"\\r\")\n    if iteration == total:\n        print()\n\ndef invoke_solver(cfg):\n    solver = run(\n        [\n            \"target/release/main\",\n            json.dumps(cfg),\n        ],\n        stdout = PIPE,\n        encoding = \"ascii\",\n        cwd = \"solver/\",\n        env = {\n            \"RUST_BACKTRACE\": \"1\",\n            **os.environ,\n        },\n    )\n    if solver.returncode != 0:\n        print(solver)\n        raise Exception(\"solver failed\")\n\n    results = []\n    stats = []\n    for line in solver.stdout.split(\"\\n\")[8:]:\n        if line.startswith(\"done: \"):\n            [_, time, inst_id, satisfied, valid, weight, err] = line.split()\n            results.append((float(time), int(inst_id), satisfied == \"true\", valid == \"true\", float(weight), float(err), stats))\n            stats = []\n        else:\n            stats.append(list(map(float, line.split())))\n    return results\n\ndef dataset(id, **kwargs):\n    params = dict({\n        # defaults\n        \"id\": [id],\n        \"set\": [\"M\"],\n        \"n_instances\": [15],\n        \"generations\": [200],\n        \"mutation_chance\": [0.02],\n        \"population_size\": [1000],\n    }, **kwargs)\n\n    key_order = [k for k in params]\n    cartesian = list(product(\n        *[params[key] for key in key_order]\n    ))\n\n    return {\n        key: [row[key_order.index(key)] for row in cartesian] for key in params\n    }\n\ndef merge_datasets(*dss):\n    return {\n        k: list(chain(*(ds[k] for ds in dss)))\n        for k in dss[0]\n    }\n\n<<datasets>>\n\ndata = pd.DataFrame()\ncfgs = [dict(zip(configs, v)) for v in zip(*configs.values())]\niteration = 0\ntotal = sum([cfg[\"n_instances\"] * cfg[\"generations\"] for cfg in cfgs])\n\nfor config in cfgs:\n    if show_progress:\n        print(end = \"\\033[2K\")\n    print(config)\n    progress_bar(iteration, total)\n\n    params = \"-\".join([str(v) for _, v in config.items()])\n    for (t, inst_id, satisfied, valid, weight, err, stats) in invoke_solver(config):\n        data = data.append(dict(config,\n            error   = err,\n            inst_id = inst_id,\n            stats   = stats,\n            time    = t,\n            valid   = valid,\n            weight  = weight,\n        ), ignore_index = True)\n\n        iteration = iteration + config[\"generations\"]\n        progress_bar(iteration, total)\n\ndata.to_pickle(\"docs/assets/measurements.pkl\")\n"]},{"t":"Div","c":[["",["doctest"],[["status","SUCCESS"]]],[{"t":"Div","c":[["",["doctestInput"],[]],[{"t":"CodeBlock","c":[["perform-measurement",["python","eval","bootstrap-fold"],[]],"# tento blok slouží pouze ke spuštění skriptu výše\n# (vynucen nedostatkem nástroje, který má tvorbu dokumentu na starosti)\n<<analysis/measure.py>>"]}]]},{"t":"Div","c":[["",["doctestResult"],[]],[{"t":"Div","c":[["",["programOutput"],[]],[{"t":"RawBlock","c":["html","<pre class=\"ansi2html-content\">{'id': 'default', 'set': 'M', 'n_instances': 15, 'generations': 1000, 'mutation_chance': 0.03, 'population_size': 1000}\n{'id': 'mutation_exploration', 'set': 'M', 'n_instances': 6, 'generations': 200, 'mutation_chance': 0.005, 'population_size': 1000}\n{'id': 'mutation_exploration', 'set': 'M', 'n_instances': 6, 'generations': 200, 'mutation_chance': 0.01, 'population_size': 1000}\n{'id': 'mutation_exploration', 'set': 'M', 'n_instances': 6, 'generations': 200, 'mutation_chance': 0.02, 'population_size': 1000}\n{'id': 'mutation_exploration', 'set': 'M', 'n_instances': 6, 'generations': 200, 'mutation_chance': 0.05, 'population_size': 1000}\n{'id': 'mutation_exploration', 'set': 'M', 'n_instances': 6, 'generations': 200, 'mutation_chance': 0.1, 'population_size': 1000}\n{'id': 'mutation_exploration', 'set': 'M', 'n_instances': 6, 'generations': 200, 'mutation_chance': 0.2, 'population_size': 1000}\n{'id': 'mutation_exploration', 'set': 'M', 'n_instances': 6, 'generations': 200, 'mutation_chance': 0.5, 'population_size': 1000}\n</pre>"]}]]}]]}]]},{"t":"Para","c":[{"t":"Str","c":"V"},{"t":"Space"},{"t":"Str","c":"tuto"},{"t":"Space"},{"t":"Str","c":"chvíli"},{"t":"Space"},{"t":"Str","c":"ještě"},{"t":"Space"},{"t":"Str","c":"nevíme,"},{"t":"Space"},{"t":"Str","c":"ve"},{"t":"Space"},{"t":"Str","c":"kterých"},{"t":"Space"},{"t":"Str","c":"oblastech"},{"t":"Space"},{"t":"Str","c":"prostoru"},{"t":"Space"},{"t":"Str","c":"všech"},{"t":"Space"},{"t":"Str","c":"konfigurací"},{"t":"SoftBreak"},{"t":"Str","c":"parametrů"},{"t":"Space"},{"t":"Str","c":"evolučního"},{"t":"Space"},{"t":"Str","c":"algoritmu"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"skrývají"},{"t":"Space"},{"t":"Str","c":"efektivní"},{"t":"Space"},{"t":"Str","c":"řešiče"},{"t":"Space"},{"t":"Str","c":"problému."},{"t":"Space"},{"t":"Str","c":"Protože"},{"t":"SoftBreak"},{"t":"Str","c":"vyhodnocení"},{"t":"Space"},{"t":"Str","c":"kartézského"},{"t":"Space"},{"t":"Str","c":"součinu"},{"t":"Space"},{"t":"Str","c":"všech"},{"t":"Space"},{"t":"Str","c":"množin"},{"t":"Space"},{"t":"Str","c":"parametrů"},{"t":"Space"},{"t":"Str","c":"by"},{"t":"Space"},{"t":"Str","c":"zabralo"},{"t":"Space"},{"t":"Str","c":"moc"},{"t":"Space"},{"t":"Str","c":"dlouho,"},{"t":"SoftBreak"},{"t":"Str","c":"zaměříme"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"pouze"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"zajímavé"},{"t":"Space"},{"t":"Str","c":"podprostory."},{"t":"Space"},{"t":"Str","c":"Ty"},{"t":"Space"},{"t":"Str","c":"jsou"},{"t":"Space"},{"t":"Str","c":"generovány"},{"t":"Space"},{"t":"Str","c":"funkcí"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"dataset"]},{"t":"Str","c":","},{"t":"SoftBreak"},{"t":"Str","c":"která"},{"t":"Space"},{"t":"Str","c":"vytvoří"},{"t":"Space"},{"t":"Str","c":"pojmenovaný"},{"t":"Space"},{"t":"Str","c":"podprostor"},{"t":"Space"},{"t":"Str","c":"konfigurací"},{"t":"Space"},{"t":"Str","c":"kartézského"},{"t":"Space"},{"t":"Str","c":"součinu"},{"t":"Space"},{"t":"Str","c":"zadaných"},{"t":"SoftBreak"},{"t":"Str","c":"hodnot"},{"t":"Space"},{"t":"Str","c":"všech"},{"t":"Space"},{"t":"Str","c":"parametrů."},{"t":"Space"},{"t":"Str","c":"Sjednocením"},{"t":"Space"},{"t":"Str","c":"těchto"},{"t":"Space"},{"t":"Str","c":"podprostorů"},{"t":"Space"},{"t":"Str","c":"dostaneme"},{"t":"Space"},{"t":"Str","c":"podprostor"},{"t":"SoftBreak"},{"t":"Str","c":"všech"},{"t":"Space"},{"t":"Str","c":"konfigurací,"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"které"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"třeba"},{"t":"Space"},{"t":"Str","c":"algoritmus"},{"t":"Space"},{"t":"Str","c":"vyhodnotit."}]},{"t":"CodeBlock","c":[["datasets",["python"],[]],"configs = merge_datasets(dataset(\n    \"default\",\n    generations = [1000],\n    mutation_chance = [0.03],\n), dataset(\n    \"mutation_exploration\",\n    n_instances = [6],\n    mutation_chance = [0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5],\n))"]},{"t":"Para","c":[{"t":"Str","c":"Po"},{"t":"Space"},{"t":"Str","c":"vyhodnocení"},{"t":"Space"},{"t":"Str","c":"algoritmu"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"různé"},{"t":"Space"},{"t":"Str","c":"parametry"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"čas"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"vizualizaci"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"analýzu"},{"t":"SoftBreak"},{"t":"Str","c":"výsledků."},{"t":"Space"},{"t":"Str","c":"O"},{"t":"Space"},{"t":"Str","c":"tu"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"stará"},{"t":"Space"},{"t":"Str","c":"další"},{"t":"Space"},{"t":"Str","c":"program,"},{"t":"Space"},{"t":"Str","c":"který"},{"t":"Space"},{"t":"Str","c":"využívá"},{"t":"Space"},{"t":"Str","c":"vizualizací"},{"t":"Space"},{"t":"Str","c":"vyvinutých"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"SoftBreak"},{"t":"Str","c":"předchozích"},{"t":"Space"},{"t":"Str","c":"úkolech,"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"přidává"},{"t":"Space"},{"t":"Str","c":"vlastní."},{"t":"Space"},{"t":"Str","c":"Rozdělení"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"dvě"},{"t":"Space"},{"t":"Str","c":"fáze"},{"t":"Space"},{"t":"Str","c":"(měření"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"SoftBreak"},{"t":"Str","c":"vizualizace"},{"t":"Space"},{"t":"Str","c":"zvlášť)"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"serializací"},{"t":"Space"},{"t":"Str","c":"do"},{"t":"Space"},{"t":"Str","c":"binárního"},{"t":"Space"},{"t":"Str","c":"souboru"},{"t":"Space"},{"t":"Str","c":"uprostřed"},{"t":"Space"},{"t":"Str","c":"vede"},{"t":"Space"},{"t":"Str","c":"ke"},{"t":"SoftBreak"},{"t":"Str","c":"zkrácení"},{"t":"Space"},{"t":"Str","c":"iteračního"},{"t":"Space"},{"t":"Str","c":"cyklu"},{"t":"Space"},{"t":"Str","c":"během"},{"t":"Space"},{"t":"Str","c":"whitebox"},{"t":"Space"},{"t":"Str","c":"fáze"},{"t":"Space"},{"t":"Str","c":"vývoje"},{"t":"Space"},{"t":"Str","c":"algoritmu."},{"t":"Space"},{"t":"Str","c":"Je-li"},{"t":"Space"},{"t":"Str","c":"třeba"},{"t":"SoftBreak"},{"t":"Str","c":"poupravit"},{"t":"Space"},{"t":"Str","c":"detaily"},{"t":"Space"},{"t":"Str","c":"grafu,"},{"t":"Space"},{"t":"Str","c":"měření"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"nemusí"},{"t":"Space"},{"t":"Str","c":"provádět"},{"t":"Space"},{"t":"Str","c":"znovu,"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"naopak."}]},{"t":"CodeBlock","c":[["",["python","bootstrap-fold"],[["file","analysis/plot.py"]]],"\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patheffects as PathEffects\nimport seaborn as sns\nimport textwrap as tr\nimport math\nimport os\n\ndata = pd.read_pickle(\"docs/assets/measurements.pkl\")\n\nshow_progress = os.environ.get(\"JUPYTER\") == None\n\nplot_labels = dict(\n    error           = \"Chyba oproti optimálnímu řešení [%]\",\n    generations     = \"Počet generací\",\n    mutation_chance = \"Pravděpodobnost mutace\",\n    n_instances     = \"Počet instancí\",\n    set             = \"Datová sada\",\n    time            = \"Doba běhu [s]\",\n    weight          = \"Váha řešení\",\n)\n\nscheduled_plots = []\n\ndef progress_bar(iteration, total, length = 60):\n    if not show_progress:\n        return\n    percent = (\"{0:.1f}\").format(100 * (iteration / float(total)))\n    filledLength = int(length * iteration // total)\n    bar = '=' * filledLength + ' ' * (length - filledLength)\n    print(f'\\r[{bar}] {percent}%', end = \"\\r\")\n    if iteration == total:\n        print()\n\ndef ridgeline(id, title, col, filename, x_label = \"Chyba oproti optimálnímu řešení [%]\", progress = lambda _: None):\n    df = data[data[\"id\"] == id]\n    series = df.groupby(col)[\"error\"].mean()\n    df[\"mean error\"] = df[col].map(series)\n\n    # plot the error distributions for each value of col\n    plt.style.use(\"default\")\n    sns.set_theme(style = \"white\", rc = {\"axes.facecolor\": (0, 0, 0, 0)})\n    pal = sns.color_palette(\"crest\", n_colors = len(df[col].unique()))\n\n    # set up the layout\n    g = sns.FacetGrid(\n        df,\n        row = col,\n        hue = \"mean error\",\n        palette = pal,\n        height = 0.75,\n        aspect = 15,\n    )\n    plt.xlim(-0.1, 1.0)\n    # distributions\n    g.map(sns.kdeplot, \"error\", clip = (-0.1, 1.0), bw_adjust = 1, clip_on = False, fill = True, alpha = 1, linewidth = 0.1)\n    # contours\n    g.map(sns.kdeplot, \"error\", clip = (-0.1, 1.0), bw_adjust = 1, clip_on = False, color = \"w\", lw = 1)\n    # horizontal lines\n    g.map(plt.axhline, y = 0, lw = 2, clip_on = False)\n    # overlap\n    g.fig.subplots_adjust(hspace = -0.3)\n\n    for i, ax in enumerate(g.axes.flat):\n        ax.annotate(\n            df[col].unique()[i],\n            (0, 0),\n            (-16.5, 3),\n            xycoords = \"axes fraction\",\n            textcoords = \"offset points\",\n            va = \"baseline\",\n            fontsize = 15,\n            color = ax.lines[-1].get_color(),\n            path_effects = [\n                PathEffects.withStroke(linewidth = 0.5, foreground = \"w\")\n            ],\n        )\n\n    # remove titles, y ticks, spines\n    g.set_titles(\"\")\n    g.set(yticks = [])\n    g.despine(left = True, bottom = True)\n    g.fig.suptitle(title, fontsize = 20, ha = \"right\")\n    for ax in g.axes.flat:\n        ax.xaxis.set_major_formatter(lambda x, pos: f\"{x * 100:.0f}\")\n    g.set_xlabels(x_label)\n    g.set_ylabels(\"\")\n\n    g.savefig(f\"docs/assets/{filename}\")\n    plt.close()\n    progress(1)\n\ndef boxplot(x_axis, y_axis, id, title, grouping_column, data = data, filename = None, progress = lambda _: None):\n    if filename is None:\n        filename = id.replace(\" \", \"_\") + \".svg\"\n    print(f\"\\t{title}\")\n    fig, ax = plt.subplots(figsize = (14, 8))\n    ds = [d for d in data if d[\"id\"] == id]\n    # create a frame from the list\n    df = pd.DataFrame(ds)\n\n    # do a grouped boxplot\n    sns.boxplot(\n        x = x_axis,\n        y = y_axis,\n        data = df,\n        hue = grouping_column,\n        ax = ax,\n        linewidth = 0.8,\n    )\n\n    # render the datapoints as dots with horizontal jitter\n    sns.stripplot(\n        x = x_axis,\n        y = y_axis,\n        data = df,\n        hue = grouping_column,\n        ax = ax,\n        jitter = True,\n        size = 4,\n        dodge = True,\n        linewidth = 0.2,\n        alpha = 0.4,\n        edgecolor = \"white\",\n    )\n\n    plt.title(title)\n    plt.xlabel(plot_labels[x_axis])\n    plt.ylabel(plot_labels[y_axis])\n\n    constant_columns = [\n        col for col in df.columns[df.nunique() <= 1]\n            if (col not in [\"id\", \"n_instances\", \"contents\"])\n    ]\n\n    caption = \"\\n\".join(tr.wrap(\"Konfigurace: {}\".format({\n        k: df[k][0] for k in constant_columns\n    }), width = 170))\n\n    fig.text(\n        0.09,\n        0.05,\n        caption,\n        fontsize = \"small\",\n        fontfamily = \"monospace\",\n        verticalalignment = \"top\",\n    )\n\n    handles, labels = ax.get_legend_handles_labels()\n    # labels = [alg_labels[l] for l in labels]\n\n    plt.legend(handles[0 : int(len(handles) / 2)], labels[0 : int(len(labels) / 2)])\n    plt.savefig(f\"docs/assets/{filename}.svg\")\n    progress(1)\n\ndef heatmap(id, title, filename, data = data, progress = lambda _: None):\n    dataset = data[data[\"id\"] == id]\n    stats = dataset[\"stats\"]\n    n_instances = int(dataset[\"inst_id\"].count())\n    n_generations = int(dataset[\"generations\"].max())\n    n_variables = len(stats[0][0]) - 2\n\n    # math.sqrt(n_generations) * 0.5\n    fig, axs = plt.subplots(1, 2 * n_instances,\n        figsize = (n_instances * n_variables * 0.15, 8),\n        gridspec_kw = {\"left\": 0.015, \"right\": 0.975, \"width_ratios\": [n_variables, 1] * n_instances},\n    )\n    fig.suptitle(title)\n\n    for i, (_, inst_id), (_, df), (_, err) in zip(\n        range(1, 100),\n        dataset[\"inst_id\"].iteritems(),\n        stats.iteritems(),\n        dataset[\"error\"].iteritems()\n    ):\n        inst_id = int(inst_id)\n        df = pd.DataFrame(df)\n        ax = axs[2 * (i - 1)]\n        err_ax = axs[2 * i - 1]\n        ax.set_title(f\"inst. {inst_id}\")\n\n        sns.heatmap(\n            df.iloc[:, 2:], # drop first column (with generation numbers) and second (with errors)\n            ax = ax,\n            vmin = 0,\n            vmax = 1,\n            square = True,\n            cmap = \"magma\",\n            xticklabels = False,\n            yticklabels = df.iloc[:, 0].map(int) if i == 1 else False,\n            cbar_kws = {\"shrink\": 0.5, \"pad\": 0.2},\n            cbar = i == n_instances,\n        )\n\n        ax_pos = ax.get_position()\n        err_pos = err_ax.get_position()\n        err_ax.set_position([ax_pos.x0 + ax_pos.width * 1.08, err_pos.y0, err_pos.width, err_pos.height])\n        mask = df.iloc[:, 1:2]\n        # disable false-positive warning\n        pd.options.mode.chained_assignment = None\n        mask[1] = mask[1].map(lambda x: x > 1)\n        sns.heatmap(\n            df.iloc[:, 1:2], # second column (error)\n            ax = err_ax,\n            vmin = 0,\n            vmax = 1,\n            square = True,\n            mask = mask,\n            cmap = \"viridis_r\",\n            xticklabels = False,\n            yticklabels = False,\n            cbar = False,\n        )\n\n        new_ticks = [i.get_text() for i in ax.get_yticklabels()]\n        ax.set_yticks(range(0, len(new_ticks), 10), new_ticks[::10])\n        ax.annotate(\n            f\"{100 * err:.2f}%\",\n            (0, 0),\n            (4, -10),\n            xycoords = \"axes fraction\",\n            textcoords = \"offset points\",\n            va = \"top\",\n        )\n        progress(1)\n\n    plt.savefig(f\"docs/assets/{filename}.svg\")\n    plt.close()\n    progress(1)\n\ndef schedule_ridgeline(*args, **kwargs):\n    scheduled_plots.append({\"type\": \"ridgeline\", \"total\": 1, \"args\": args, \"kwargs\": kwargs})\n\ndef schedule_boxplot(*args, **kwargs):\n    scheduled_plots.append({\"type\": \"boxplot\",   \"total\": 1, \"args\": args, \"kwargs\": kwargs})\n\ndef schedule_heatmap(id, *args, data = data, **kwargs):\n    dataset = data[data[\"id\"] == id]\n    n_instances = int(dataset[\"inst_id\"].count())\n    scheduled_plots.append({\n        \"type\": \"heatmap\",\n        \"total\": n_instances + 1,\n        \"args\": [id] + list(args),\n        \"kwargs\": dict(kwargs, data = data)\n    })\n\ndef plottery():\n    iteration = 0\n    total = sum(p[\"total\"] for p in scheduled_plots)\n    progress_bar(iteration, total)\n    for plot in scheduled_plots:\n        def progress(i):\n            nonlocal iteration\n            iteration += i\n            progress_bar(iteration, total)\n        if plot[\"type\"] == \"ridgeline\":\n            ridgeline(*plot[\"args\"], progress = progress, **plot[\"kwargs\"])\n        elif plot[\"type\"] == \"boxplot\":\n            boxplot(*plot[\"args\"], progress = progress, **plot[\"kwargs\"])\n        elif plot[\"type\"] == \"heatmap\":\n            heatmap(*plot[\"args\"], progress = progress, **plot[\"kwargs\"])\n\nschedule_ridgeline(\n    \"mutation_exploration\",\n    \"Vliv šance mutace na hustotu chyb\",\n    \"mutation_chance\",\n    \"whitebox-mutation-chance-error.svg\",\n)\n\nschedule_heatmap(\n    \"default\",\n    \"Vývoj populace ve výchozím nastavení\",\n    \"whitebox-heatmap-default-mix\",\n    data = data[data[\"inst_id\"] <= 8]\n)\n\n# for _, mutation_chance in data[data[\"id\"] == \"mutation_exploration\"][\"mutation_chance\"].iteritems():\n#     schedule_heatmap(\n#         \"mutation_exploration\",\n#         f\"Vývoj populace s šancí mutace {mutation_chance * 100}%\",\n#         f\"whitebox-heatmap-mut-explr-{mutation_chance}\",\n#         data = data[data[\"mutation_chance\"] == mutation_chance]\n#     )\n\n# do the plottery\nplottery()\n"]},{"t":"Div","c":[["",["doctest"],[["status","SUCCESS"]]],[{"t":"Div","c":[["",["doctestInput"],[]],[{"t":"CodeBlock","c":[["generate-plots",["python","eval","bootstrap-fold"],[]],"# tento blok slouží pouze ke spuštění skriptu výše\n# (vynucen nedostatkem nástroje, který má tvorbu dokumentu na starosti)\n<<analysis/plot.py>>"]}]]},{"t":"Div","c":[["",["doctestResult"],[]],[{"t":"Div","c":[["",["programOutput"],[]],[{"t":"RawBlock","c":["html","<pre class=\"ansi2html-content\">/tmp/ipykernel_2225/2724113832.py:41: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  df[\"mean error\"] = df[col].map(series)\n</pre>"]}]]}]]}]]},{"t":"Para","c":[{"t":"Str","c":"Vůbec"},{"t":"Space"},{"t":"Str","c":"první"},{"t":"Space"},{"t":"Str","c":"varianta"},{"t":"Space"},{"t":"Str","c":"algoritmu"},{"t":"Space"},{"t":"Str","c":"nevyužívá"},{"t":"Space"},{"t":"Str","c":"žádných"},{"t":"Space"},{"t":"Str","c":"metod"},{"t":"Space"},{"t":"Str","c":"nichingu,"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"každé"},{"t":"Space"},{"t":"Str","c":"ze"},{"t":"Space"},{"t":"Str","c":"dvou"},{"t":"SoftBreak"},{"t":"Str","c":"set"},{"t":"Space"},{"t":"Str","c":"generací"},{"t":"Space"},{"t":"Str","c":"nekompromisně"},{"t":"Space"},{"t":"Str","c":"vyřadí"},{"t":"Space"},{"t":"Str","c":"slabší"},{"t":"Space"},{"t":"Str","c":"půlku"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Str","c":"populace"},{"t":"Space"},{"t":"Str","c":"tisíce"},{"t":"Space"},{"t":"Str","c":"jedinců"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"SoftBreak"},{"t":"Str","c":"rodiče"},{"t":"Space"},{"t":"Str","c":"kombinuje"},{"t":"Space"},{"t":"Str","c":"do"},{"t":"Space"},{"t":"Str","c":"nových"},{"t":"Space"},{"t":"Str","c":"potomků"},{"t":"Space"},{"t":"Str","c":"uniformním"},{"t":"Space"},{"t":"Str","c":"křížením."}]},{"t":"Para","c":[{"t":"Image","c":[["",[],[]],[{"t":"Str","c":"První"},{"t":"Space"},{"t":"Str","c":"nástřel"},{"t":"Space"},{"t":"Str","c":"evolučního"},{"t":"Space"},{"t":"Str","c":"algoritmu"}],["whitebox-default-0.svg","fig:"]]}]},{"t":"Para","c":[{"t":"Image","c":[["",[],[]],[{"t":"Str","c":"Vývoj"},{"t":"Space"},{"t":"Str","c":"populace"},{"t":"Space"},{"t":"Str","c":"po"},{"t":"Space"},{"t":"Str","c":"200"},{"t":"Space"},{"t":"Str","c":"generací"}],["assets/whitebox-heatmap-default-mix.svg","fig:"]]}]},{"t":"Para","c":[{"t":"Image","c":[["",[],[]],[{"t":"Str","c":"Šance"},{"t":"Space"},{"t":"Str","c":"mutace"},{"t":"Space"},{"t":"Str","c":"vs. hustota"},{"t":"Space"},{"t":"Str","c":"chyb"}],["assets/whitebox-mutation-chance-error.svg","fig:"]]}]},{"t":"Header","c":[3,["black-box-vyhodnocení-hustoty-chyb",[],[]],[{"t":"Str","c":"Black"},{"t":"Space"},{"t":"Str","c":"box:"},{"t":"Space"},{"t":"Str","c":"vyhodnocení"},{"t":"Space"},{"t":"Str","c":"hustoty"},{"t":"Space"},{"t":"Str","c":"chyb"}]]},{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"TODO"}]}]},{"t":"Header","c":[2,["implementace",[],[]],[{"t":"Str","c":"Implementace"}]]},{"t":"Para","c":[{"t":"Str","c":"Program"},{"t":"Space"},{"t":"Str","c":"začíná"},{"t":"Space"},{"t":"Str","c":"definicí"},{"t":"Space"},{"t":"Str","c":"datové"},{"t":"Space"},{"t":"Str","c":"struktury"},{"t":"Space"},{"t":"Str","c":"reprezentující"},{"t":"Space"},{"t":"Str","c":"instanci"},{"t":"Space"},{"t":"Str","c":"problému"},{"t":"SoftBreak"},{"t":"Str","c":"batohu."}]},{"t":"CodeBlock","c":[["problem-instance-definition",["rust","bootstrap-fold"],[]],"pub type Id = NonZeroU16;\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct Literal(pub bool, pub Id);\npub type Clause = [Literal; 3];\n\nconst MAX_CLAUSES: usize = 512;\nconst MAX_VARIABLES: usize = 256;\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct Instance {\n    pub id: i32,\n    pub weights: ArrayVec<NonZeroU16, MAX_VARIABLES>,\n    pub clauses: ArrayVec<Clause, MAX_CLAUSES>,\n}\n"]},{"t":"Para","c":[{"t":"Str","c":"Následující"},{"t":"Space"},{"t":"Str","c":"úryvek"},{"t":"Space"},{"t":"Str","c":"poskytuje"},{"t":"Space"},{"t":"Str","c":"ptačí"},{"t":"Space"},{"t":"Str","c":"pohled"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"strukturu"},{"t":"Space"},{"t":"Str","c":"souboru."},{"t":"Space"},{"t":"Str","c":"Použité"},{"t":"Space"},{"t":"Str","c":"knihovny"},{"t":"SoftBreak"},{"t":"Str","c":"jsou"},{"t":"Space"},{"t":"Str","c":"importovány"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"začátku,"},{"t":"Space"},{"t":"Str","c":"následuje"},{"t":"Space"},{"t":"Str","c":"již"},{"t":"Space"},{"t":"Str","c":"zmíněná"},{"t":"Space"},{"t":"Str","c":"definice"},{"t":"Space"},{"t":"Str","c":"instance"},{"t":"Space"},{"t":"Str","c":"problému,"},{"t":"SoftBreak"},{"t":"Str","c":"dále"},{"t":"Space"},{"t":"Str","c":"funkce"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"main()"]},{"t":"Str","c":","},{"t":"Space"},{"t":"Str","c":"parser,"},{"t":"Space"},{"t":"Str","c":"definice"},{"t":"Space"},{"t":"Str","c":"struktury"},{"t":"Space"},{"t":"Str","c":"řešení"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"její"},{"t":"Space"},{"t":"Str","c":"podpůrné"},{"t":"Space"},{"t":"Str","c":"funkce,"},{"t":"SoftBreak"},{"t":"Str","c":"samotné"},{"t":"Space"},{"t":"Str","c":"algoritmy"},{"t":"Space"},{"t":"Str","c":"řešiče"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"neposlední"},{"t":"Space"},{"t":"Str","c":"řadě"},{"t":"Space"},{"t":"Str","c":"sada"},{"t":"Space"},{"t":"Str","c":"automatických"},{"t":"Space"},{"t":"Str","c":"testů."}]},{"t":"CodeBlock","c":[["",["rust","bootstrap-fold"],[["file","solver/src/lib.rs"]]],"<<imports>>\n\nuse std::result::Result as IOResult;\npub fn list_input_files(set: &str, r: Range<u32>) -> Result<Vec<IOResult<DirEntry, std::io::Error>>> {\n    let f = |res: &IOResult<DirEntry, std::io::Error> | res.as_ref().ok().filter(|f| {\n        let file_name = f.file_name();\n        let file_name = file_name.to_str().unwrap();\n        // keep only regular files\n        f.file_type().unwrap().is_file() &&\n        // ... whose names start with the set name,\n        file_name.starts_with(set) &&\n        // ... continue with an integer between 0 and 15,\n        file_name[set.len()..]\n        .split('_').next().unwrap().parse::<u32>().ok()\n        .filter(|n| r.contains(n)).is_some() &&\n        // ... and end with `_inst.dat` (for \"instance\").\n        file_name.ends_with(\"_inst.dat\")\n    }).is_some();\n    Ok(read_dir(\"./ds/\")?.filter(f).collect())\n}\n\n<<problem-instance-definition>>\n\n<<solution-definition>>\n\n<<parser>>\n\ntrait IteratorRandomWeighted: Iterator + Sized + Clone {\n    fn choose_weighted<Rng: ?Sized, W>(&mut self, rng: &mut Rng, f: fn(Self::Item) -> W) -> Option<Self::Item>\n    where\n        Rng: rand::Rng,\n        W: for<'a> core::ops::AddAssign<&'a W>\n         + rand::distributions::uniform::SampleUniform\n         + std::cmp::PartialOrd\n         + Default\n         + Clone {\n        use rand::prelude::*;\n        let dist = rand::distributions::WeightedIndex::new(self.clone().map(f)).ok()?;\n        self.nth(dist.sample(rng))\n    }\n}\n\nimpl<I> IteratorRandomWeighted for I where I: Iterator + Sized + Clone {}\n\nimpl Instance {\n    pub fn evolutionary<Rng: rand::Rng + Send + Sync + Clone>(\n        &self,\n        rng: &mut Rng,\n        mut ecfg: EvolutionaryConfig,\n        opt: Option<&OptimalSolution>\n    ) -> Solution {\n        use rayon::prelude::*;\n        use std::iter::repeat_with;\n\n        impl<'a> Solution<'a> {\n            fn fitness(&self, _evo_config: &EvolutionaryConfig) -> u64 {\n                if !self.satisfied { 0 }\n                else { self.weight as u64 }\n            }\n\n            fn crossover<Rng: rand::Rng>(\n                self, other: Self, evo_config: &EvolutionaryConfig, rng: &mut Rng\n            ) -> [Solution<'a>; 2] {\n                let mut cfgs = [Config::zeroed(), Config::zeroed()];\n                let mut weights = [0, 0];\n                for (i, (l, r)) in self\n                    .cfg.iter()\n                    .zip(other.cfg.iter())\n                    .take(self.inst.weights.len())\n                    .enumerate() {\n                    let bits = if rng.gen_bool(0.5) { (*l, *r) } else { (*r, *l) };\n                    cfgs[0].set(i, bits.0);\n                    cfgs[1].set(i, bits.1);\n                    let w = self.inst.weights[i].get() as u32;\n                    weights[0] += w * bits.0 as u32;\n                    weights[1] += w * bits.1 as u32;\n                }\n\n                cfgs.into_iter()\n                    .zip(weights.into_iter())\n                    .map(|(cfg, weight)| Solution{weight, cfg, inst: self.inst, satisfied: false})\n                    .map(|sln| sln.mutate_unsafe(evo_config, rng))\n                    .map(|sln| Solution { satisfied: satisfied(&sln.inst.clauses, &sln.cfg), ..sln })\n                    .collect::<ArrayVec<_, 2>>()\n                    .into_inner()\n                    .unwrap()\n            }\n\n            pub fn mutate_unsafe<Rng: rand::Rng>(\n                &self, evo_config: &EvolutionaryConfig, rng: &mut Rng\n            ) -> Solution<'a> {\n                let mut new = *self;\n                for i in 0..self.inst.weights.len() {\n                    let flip = rng.gen_bool(evo_config.mutation_chance);\n                    new.set_unsafe(i, if flip { !self.cfg[i] } else { self.cfg[i] });\n                }\n\n                new\n            }\n        }\n\n        let random = |rng: &mut Rng| {\n            let mut cfg = Config::zeroed();\n            let mut weight = 0;\n            for i in 0..self.weights.len() {\n                let b = rng.gen_bool(0.5);\n                cfg.set(i, b);\n                weight += self.weights[i].get() as u32 * b as u32;\n            }\n\n            Solution::new(weight, cfg, self)\n        };\n\n        fn stats(pop: &[Solution], _evo_config: EvolutionaryConfig, opt: Option<&OptimalSolution>) -> String {\n            let identity = core::iter::repeat(0u16).take(MAX_VARIABLES)\n                .collect::<ArrayVec<_, MAX_VARIABLES>>().into_inner().unwrap();\n            let counts = pop.par_iter()\n                .map(|sln| sln.cfg.iter()\n                    .map(|b| *b as u16)\n                    .collect::<ArrayVec<_, MAX_VARIABLES>>().into_inner().unwrap()\n                )\n                .reduce(|| identity, |l, r|\n                    l.iter().zip(r.iter())\n                    .map(|(x, y)| x + y)\n                    .collect::<ArrayVec<_, MAX_VARIABLES>>().into_inner().unwrap()\n                );\n\n            let vars = pop[0].inst.weights.len();\n            opt.and_then(|opt| {\n                    pop.iter()\n                        .filter(|sln| sln.satisfied)\n                        .map(|sln| (1, sln.weight as f64 / opt.weight as f64))\n                        .reduce(|acc, (n, w)| (acc.0 + n, acc.1 + w))\n                        .map(|(count, sum)| 1.0 - sum / count as f64)\n                }).or(Some(2.0)) // fill in the error if there's no known optimum\n                .into_iter()\n                .chain(counts.into_iter().take(vars).map(|x| x as f64 / pop.len() as f64))\n                .map(|x| x.to_string())\n                .intersperse(\" \".into())\n                .collect::<String>()\n        }\n\n        const DISASTER_INTERVAL: u32 = 100;\n        const MUTATION_ADJUSTMENT_INTERVAL: u32 = 10;\n\n        let mut population = (0..ecfg.population_size).map(|_| random(rng)).collect::<Vec<_>>();\n        let mut buffer = Vec::with_capacity(population.len() / 2);\n        let mut shuffler: Vec<Solution> = buffer.clone();\n        let mut best = population[0];\n        println!(\"0 {}\", stats(&population[..], ecfg, opt));\n\n        (0..ecfg.generations).for_each(|i| {\n            if i % DISASTER_INTERVAL == 0 {\n                population.shuffle(rng);\n                let n = (population.len() as f64 * 0.99) as usize;\n                population.drain(.. n);\n                population.extend(repeat_with(|| random(rng)).take(n));\n            }\n\n            population.par_sort_by_key(|sln| -(sln.fitness(&ecfg) as i64));\n            if (population[0].satisfied && !best.satisfied) || population[0].fitness(&ecfg) > best.fitness(&ecfg) {\n                best = population[0];\n            }\n\n            shuffler.par_extend(population.par_iter());\n            shuffler.shuffle(rng);\n            // move unsatisfying solutions to the end\n            shuffler.par_sort_by_key(|sln| sln.fitness(&ecfg) == 0);\n\n            // how many individuals to cross over\n            let n = population.len() / 5;\n            buffer.extend(shuffler.drain(..)\n                .zip(population.drain(.. n * 2).take(n))\n                .flat_map(|(a, b)| {\n                    a.crossover(b, &ecfg, rng).into_iter()\n                })\n            );\n\n            population.append(&mut buffer);\n            #[allow(clippy::modulo_one)]\n            if (i + 1) % (ecfg.generations / 100) == 0 {\n                println!(\"{} {}\", i + 1, stats(&population[..], ecfg, opt))\n            }\n            assert_eq!(population.len(), ecfg.population_size);\n\n            // adjust the mutation modifier adaptively\n            if i % MUTATION_ADJUSTMENT_INTERVAL == 0 {\n                let n = population.iter()\n                    .map(|sln| sln.fitness(&ecfg))\n                    .filter(|f| *f == 0)\n                    .count();\n                let n = n as f64 / population.len() as f64;\n                ecfg.mutation_chance = match () {\n                    _ if n > 0.5 => (ecfg.mutation_chance * 1.05).min(0.5),\n                    _ if n < 0.2 => (ecfg.mutation_chance / 1.05).max(0.0001),\n                    _            => ecfg.mutation_chance\n                };\n            }\n        });\n\n        best\n    }\n\n    pub fn dump(&self) -> String {\n        use core::iter::once;\n\n        once(\"w\".into())\n        .chain(self.weights.iter()\n            .map(|id| id.get())\n            .chain(once(0))\n            .map(|w| w.to_string())\n        )\n        .intersperse(\" \".into())\n        .chain(once(\"\\n\".into()))\n        .chain(self.clauses.iter().flat_map(|clause|\n            clause.iter().map(|&Literal(pos, id)|\n                    id.get() as i16 * if pos { 1 } else { -1 }\n                )\n                .chain(once(0))\n                .map(|l| l.to_string())\n                .intersperse(\" \".into())\n                .chain(once(\"\\n\".into()))\n        ))\n        .collect()\n    }\n}\n\n<<tests>>"]},{"t":"Para","c":[{"t":"Str","c":"Řešení"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"podobě"},{"t":"Space"},{"t":"Str","c":"datové"},{"t":"Space"},{"t":"Str","c":"struktury"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"Solution"]},{"t":"Space"},{"t":"Str","c":"má"},{"t":"Space"},{"t":"Str","c":"kromě"},{"t":"Space"},{"t":"Str","c":"reference"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"instanci"},{"t":"SoftBreak"},{"t":"Str","c":"problému"},{"t":"Space"},{"t":"Str","c":"především"},{"t":"Space"},{"t":"Str","c":"bit"},{"t":"Space"},{"t":"Str","c":"array"},{"t":"Space"},{"t":"Str","c":"udávající"},{"t":"Space"},{"t":"Str","c":"množinu"},{"t":"Space"},{"t":"Str","c":"předmětů"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"pomyslném"},{"t":"Space"},{"t":"Str","c":"batohu."},{"t":"SoftBreak"},{"t":"Str","c":"Zároveň"},{"t":"Space"},{"t":"Str","c":"nese"},{"t":"Space"},{"t":"Str","c":"informaci"},{"t":"Space"},{"t":"Str","c":"o"},{"t":"Space"},{"t":"Str","c":"počtu"},{"t":"Space"},{"t":"Str","c":"navštívených"},{"t":"Space"},{"t":"Str","c":"konfigurací"},{"t":"Space"},{"t":"Str","c":"při"},{"t":"Space"},{"t":"Str","c":"jeho"},{"t":"Space"},{"t":"Str","c":"výpočtu."}]},{"t":"CodeBlock","c":[["solution-definition",["rust","bootstrap-fold"],[]],"pub type Config = BitArr!(for MAX_VARIABLES);\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct Solution<'a> {\n    pub weight: u32,\n    pub cfg: Config,\n    pub inst: &'a Instance,\n    pub satisfied: bool,\n}\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct OptimalSolution {\n    pub full_id: String,\n    pub id: i32,\n    pub weight: u32,\n    pub cfg: Config,\n    pub params: InstanceParams,\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct InstanceParams {\n    variables: u8,\n    clauses: u16,\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Serialize, Deserialize)]\npub struct EvolutionaryConfig {\n    pub set: char,\n    pub mutation_chance: f64,\n    pub n_instances: u16,\n    pub generations: u32,\n    pub population_size: usize,\n}\n\nimpl From<Instance> for InstanceParams {\n    fn from(inst: Instance) -> Self {\n        InstanceParams {\n            variables: inst.weights.len() as u8,\n            clauses:   inst.clauses.len() as u16,\n        }\n    }\n}\n\nimpl From<OptimalSolution> for InstanceParams {\n    fn from(opt: OptimalSolution) -> Self {\n        opt.params\n    }\n}\n\n<<solution-helpers>>"]},{"t":"Para","c":[{"t":"Str","c":"Protože"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"strukturami"},{"t":"Space"},{"t":"Str","c":"typu"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"Solution"]},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"algoritmech"},{"t":"Space"},{"t":"Str","c":"pracuje"},{"t":"Space"},{"t":"Str","c":"hojně,"},{"t":"SoftBreak"},{"t":"Str","c":"implementoval"},{"t":"Space"},{"t":"Str","c":"jsem"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"ně"},{"t":"Space"},{"t":"Str","c":"koncept"},{"t":"Space"},{"t":"Str","c":"řazení"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"pomocné"},{"t":"Space"},{"t":"Str","c":"metody"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"počítání"},{"t":"SoftBreak"},{"t":"Str","c":"navštívených"},{"t":"Space"},{"t":"Str","c":"konfigurací"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"přidávání"},{"t":"Space"},{"t":"Str","c":"předmětů"},{"t":"Space"},{"t":"Str","c":"do"},{"t":"Space"},{"t":"Str","c":"batohu."}]},{"t":"CodeBlock","c":[["solution-helpers",["rust","bootstrap-fold"],[]],"impl <'a> PartialOrd for Solution<'a> {\n    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n        Some(self.weight.cmp(&other.weight))\n    }\n}\n\nimpl <'a> Ord for Solution<'a> {\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\n#[allow(unused)]\nimpl <'a> Solution<'a> {\n    fn with(mut self, i: usize) -> Solution<'a> {\n        self.set(i, true)\n    }\n\n    fn without(mut self, i: usize) -> Solution<'a> {\n        self.set(i, false)\n    }\n\n    fn invert(mut self) -> Solution<'a> {\n        for i in 0..self.inst.weights.len() {\n            self.set_unsafe(i, !self.cfg[i]);\n        }\n        self.satisfied = satisfied(&self.inst.clauses, &self.cfg);\n        self\n    }\n\n    fn set(&mut self, i: usize, set: bool) -> Solution<'a> {\n        self.set_unsafe(i, set);\n        self.satisfied = satisfied(&self.inst.clauses, &self.cfg);\n        *self\n    }\n\n    fn set_unsafe(&mut self, i: usize, set: bool) -> Solution<'a> {\n        let w = self.inst.weights[i];\n        let k = if set { 1 } else { -1 };\n        if self.cfg[i] != set {\n            self.cfg.set(i, set);\n            self.weight = (self.weight as i32 + k * w.get() as i32) as u32;\n        }\n        *self\n    }\n\n    fn default(inst: &'a Instance) -> Solution<'a> {\n        Solution::new(0, Config::default(), inst)\n    }\n\n    pub fn new(weight: u32, cfg: Config, inst: &'a Instance) -> Solution<'a> {\n        Solution {\n            weight, cfg, inst, satisfied: satisfied(&inst.clauses, &cfg)\n        }\n    }\n\n    pub fn valid(&self) -> bool {\n        let Solution { weight, cfg, inst, satisfied } = *self;\n        let Instance { weights, clauses, .. } = inst;\n\n        let computed_weight = weights\n            .iter()\n            .zip(cfg)\n            .map(|(w, b)| {\n                if b { w.get() as u32 } else { 0 }\n            })\n            .sum::<u32>();\n\n        computed_weight == weight && satisfied\n    }\n\n    pub fn dump(&self) -> String {\n        dump_solution(self.inst.id, self.weight, &self.cfg, &self.inst.clone().into())\n    }\n}\n\nimpl OptimalSolution {\n    pub fn dump(&self) -> String {\n        dump_solution(self.id, self.weight, &self.cfg, &self.clone().into())\n    }\n}\n\nfn dump_solution(id: i32, weight: u32, cfg: &Config, params: &InstanceParams) -> String {\n    use core::iter::once;\n    once(format!(\"uf{}-0{}\", params.variables, id))\n    .chain(once(weight.to_string()))\n    .chain((1..=params.variables as usize)\n        .map(|i| if cfg[i - 1] { 1 } else { -1 } * i as i16)\n        .chain(once(0))\n        .map(|id| id.to_string())\n    )\n    .intersperse(\" \".into())\n    .collect()\n}\n\npub fn satisfied(clauses: &ArrayVec<Clause, MAX_CLAUSES>, cfg: &Config) -> bool {\n    clauses.iter().all(|clause| clause\n        .iter()\n        .any(|&Literal(pos, id)| pos == cfg[id.get() as usize - 1])\n    )\n}\n"]},{"t":"Header","c":[2,["závěr",[],[]],[{"t":"Str","c":"Závěr"}]]},{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"TODO"}]}]},{"t":"Header","c":[2,["appendix",[],[]],[{"t":"Str","c":"Appendix"}]]},{"t":"Para","c":[{"t":"Str","c":"Dodatek"},{"t":"Space"},{"t":"Str","c":"obsahuje"},{"t":"Space"},{"t":"Str","c":"nezajímavé"},{"t":"Space"},{"t":"Str","c":"části"},{"t":"Space"},{"t":"Str","c":"implementace,"},{"t":"Space"},{"t":"Str","c":"jako"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"import"},{"t":"Space"},{"t":"Str","c":"symbolů"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"SoftBreak"},{"t":"Str","c":"knihoven."}]},{"t":"CodeBlock","c":[["imports",["rust","bootstrap-fold"],[]],"#![feature(iter_intersperse)]\n\nuse serde::{Deserialize, Serialize};\nuse std::{cmp,\n    ops::Range,\n    str::FromStr,\n    io::{BufRead, BufReader},\n    collections::{HashMap},\n    fs::{read_dir, File, DirEntry},\n    num::NonZeroU16,\n};\nuse anyhow::{Context, Result, anyhow};\nuse bitvec::prelude::BitArr;\nuse arrayvec::ArrayVec;\nuse rand::prelude::SliceRandom;\n\n#[cfg(test)]\nextern crate quickcheck_macros;"]},{"t":"Para","c":[{"t":"Str","c":"Zpracování"},{"t":"Space"},{"t":"Str","c":"vstupu"},{"t":"Space"},{"t":"Str","c":"zajišťuje"},{"t":"Space"},{"t":"Str","c":"jednoduchý"},{"t":"Space"},{"t":"Str","c":"parser"},{"t":"Space"},{"t":"Str","c":"pracující"},{"t":"Space"},{"t":"Str","c":"řádek"},{"t":"Space"},{"t":"Str","c":"po"},{"t":"Space"},{"t":"Str","c":"řádku."},{"t":"Space"},{"t":"Str","c":"Pro"},{"t":"SoftBreak"},{"t":"Str","c":"testy"},{"t":"Space"},{"t":"Str","c":"je"},{"t":"Space"},{"t":"Str","c":"tu"},{"t":"Space"},{"t":"Str","c":"parser"},{"t":"Space"},{"t":"Str","c":"formátu"},{"t":"Space"},{"t":"Str","c":"souborů"},{"t":"Space"},{"t":"Str","c":"s"},{"t":"Space"},{"t":"Str","c":"optimálními"},{"t":"Space"},{"t":"Str","c":"řešeními."}]},{"t":"CodeBlock","c":[["parser",["rust","bootstrap-fold"],[]],"<<boilerplate>>\n\npub fn parse_clauses<T: Iterator<Item = String>>(lines: &mut T) -> Result<ArrayVec<Clause, MAX_CLAUSES>> {\n    let to_literal: fn(i16) -> Result<Literal> = |n| Ok(Literal(\n        n.is_positive(), NonZeroU16::new(n.abs() as u16).ok_or_else(|| anyhow!(\"variables start from 1\"))?\n    ));\n    let mut clauses = ArrayVec::new();\n\n    for line in lines {\n        let mut numbers = line.split_whitespace();\n        clauses.push([\n            to_literal(numbers.parse_next()?)?,\n            to_literal(numbers.parse_next()?)?,\n            to_literal(numbers.parse_next()?)?,\n        ]);\n    }\n\n    Ok(clauses)\n}\n\nfn parse_solution_line<T: BufRead>(mut stream: T, params: InstanceParams) -> Result<Option<OptimalSolution>> {\n    let mut input = String::new();\n    if stream.read_line(&mut input)? == 0 {\n        return Ok(None)\n    }\n\n    let mut line = input.split_whitespace();\n    let full_id: String = line.parse_next()?;\n    let id = full_id.split('-').skip(1).parse_next()?;\n    let weight = line.parse_next()?;\n\n    let mut cfg = Config::default();\n    let mut i = 0;\n    loop {\n        let a: i16 = line.parse_next()?;\n        if a == 0 { break }\n        cfg.set(i, a.is_positive());\n        i += 1;\n    }\n\n    Ok(Some(OptimalSolution {full_id, id, weight, cfg, params}))\n}\n\npub fn load_instances(set: char) -> Result<Vec<Instance>> {\n    read_dir(\"../data/\")?.filter_map(|entry| entry.ok()\n        .filter(|entry|\n            entry.file_name().into_string().unwrap().ends_with(&(set.to_string() + \"1\"))\n        )\n        .and_then(|entry|\n            entry.file_type().ok().filter(|&typ| typ.is_dir()).and(Some(entry))\n        )\n    )\n    .flat_map(|dir| {\n        let params = params_from_filename(&dir.file_name().into_string().unwrap()).unwrap();\n        read_dir(dir.path()).into_iter()\n            .flatten().flatten()\n            .map(move |file| (params, file))\n    })\n    .map(|(_params, file)| {\n        let id = file.file_name().into_string().unwrap().split('-')\n            .nth(1).unwrap().split('.').next().unwrap().parse().unwrap();\n\n        let mut lines = BufReader::new(File::open(file.path()).unwrap())\n            .lines()\n            .map(|l| l.unwrap());\n\n        let weights_row = lines.find(|s| s.starts_with('w'))\n            .ok_or_else(|| anyhow!(\"could not find the weights row\"))?;\n\n        let weights = weights_row\n            .split_whitespace()\n            .skip(1)\n            .flat_map(|w| w /* will fail for w == 0 */.parse().into_iter()).collect();\n\n        let mut lines = lines.filter(|l| !l.starts_with('c'));\n        let clauses = parse_clauses(&mut lines)?;\n        Ok(Instance { id, weights, clauses })\n    }).collect()\n}\n\nfn params_from_filename(filename: &str) -> Result<InstanceParams> {\n    let mut params = filename[3..].split('-').take(2).map(|n| n.parse::<u16>());\n    let variables = params.next().unwrap()? as u8;\n    let clauses = params.next().unwrap()?;\n    Ok(InstanceParams { variables, clauses })\n}\n\npub fn load_solutions(set: char) -> Result<HashMap<(InstanceParams, i32), OptimalSolution>> {\n    let mut solutions = HashMap::new();\n\n    let files = read_dir(\"../data/\")?\n        .filter(|res| res.as_ref().ok().filter(|f| {\n            let name = f.file_name().into_string().unwrap();\n            f.file_type().unwrap().is_file() &&\n            name.ends_with(&(set.to_string() + \"-opt.dat\"))\n        }).is_some());\n\n    for file in files {\n        let file = file?;\n        let filename = file.file_name().into_string().expect(\"FS error\");\n        let params = params_from_filename(&filename)?;\n\n        let mut stream = BufReader::new(File::open(file.path())?);\n        while let Some(opt) = parse_solution_line(&mut stream, params)? {\n            assert!(solutions.insert((params, opt.id), opt).is_none());\n        }\n    }\n\n    Ok(solutions)\n}"]},{"t":"Para","c":[{"t":"Str","c":"Trait"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"Boilerplate"]},{"t":"Space"},{"t":"Str","c":"definuje"},{"t":"Space"},{"t":"Str","c":"funkci"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"parse_next"]},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"zkrácení"},{"t":"Space"},{"t":"Str","c":"zápisu"},{"t":"Space"},{"t":"Str","c":"zpracování"},{"t":"SoftBreak"},{"t":"Str","c":"vstupu."}]},{"t":"CodeBlock","c":[["boilerplate",["rust","bootstrap-fold"],[]],"trait Boilerplate {\n    fn parse_next<T: FromStr>(&mut self) -> Result<T>\n      where <T as FromStr>::Err: std::error::Error + Send + Sync + 'static;\n}\n\nimpl<'a, Iter> Boilerplate for Iter where Iter: Iterator<Item = &'a str> {\n    fn parse_next<T: FromStr>(&mut self) -> Result<T>\n      where <T as FromStr>::Err: std::error::Error + Send + Sync + 'static {\n        let str = self.next().ok_or_else(|| anyhow!(\"unexpected end of input\"))?;\n        str.parse::<T>()\n           .with_context(|| anyhow!(\"cannot parse {}\", str))\n    }\n}"]},{"t":"Header","c":[3,["měření-výkonu",[],[]],[{"t":"Str","c":"Měření"},{"t":"Space"},{"t":"Str","c":"výkonu"}]]},{"t":"Para","c":[{"t":"Str","c":"Benchmark"},{"t":"Space"},{"t":"Str","c":"z"},{"t":"Space"},{"t":"Str","c":"minulého"},{"t":"Space"},{"t":"Str","c":"úkolu"},{"t":"Space"},{"t":"Str","c":"postavený"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"knihovně"},{"t":"SoftBreak"},{"t":"Link","c":[["",[],[]],[{"t":"Code","c":[["",[],[]],"Criterion.rs"]}],["https://crates.io/crates/criterion",""]]},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"nachází"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"souboru"},{"t":"Space"},{"t":"Str","c":"níže."},{"t":"SoftBreak"},{"t":"Str","c":"Pro"},{"t":"Space"},{"t":"Str","c":"měření"},{"t":"Space"},{"t":"Str","c":"těchto"},{"t":"Space"},{"t":"Str","c":"experimentů"},{"t":"Space"},{"t":"Str","c":"ale"},{"t":"Space"},{"t":"Str","c":"nebyl"},{"t":"Space"},{"t":"Str","c":"použit."}]},{"t":"CodeBlock","c":[["",["rust","bootstrap-fold"],[["file","solver/benches/bench.rs"]]],"extern crate solver;\n\nuse solver::*;\nuse anyhow::{Result, anyhow};\nuse std::{collections::HashMap, fs::File, io::{BufReader, Write}, ops::Range, time::Duration};\nuse criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};\n\nfn full(c: &mut Criterion) -> Result<()> {\n    let algs = get_algorithms();\n    let mut solutions = HashMap::new();\n    let ranges = HashMap::from([\n        (\"bb\",     0..=25),\n        (\"dpw\",    0..=32),\n        (\"dpc\",    0..=20),\n        (\"fptas1\", 0..=32),\n        (\"fptas2\", 0..=22),\n        (\"greedy\", 0..=32),\n        (\"redux\",  0..=32),\n    ]);\n\n    let mut input: HashMap<(&str, u32), Vec<Instance>> = HashMap::new();\n    let ns = [4, 10, 15, 20, 22, 25, 27, 30, 32];\n    let sets = [\"NK\", \"ZKC\", \"ZKW\"];\n    for set in sets {\n        solutions.insert(set, load_solutions(set)?);\n        for n in ns {\n            input.insert((set, n), load_input(set, n .. n + 1)?\n                .into_iter()\n                .rev()\n                .take(100)\n                .collect()\n            );\n        }\n    }\n\n    benchmark(algs, c, &ns, &sets, ranges, solutions, input)?;\n    Ok(())\n}\n\nfn benchmark(\n    algs: std::collections::BTreeMap<&str, fn(&Instance) -> Solution>,\n    c: &mut Criterion,\n    ns: &[u32],\n    sets: &[&'static str],\n    ranges: HashMap<&str, std::ops::RangeInclusive<u32>>,\n    solutions: HashMap<&str, HashMap<(u32, i32), OptimalSolution>>,\n    input: HashMap<(&str, u32), Vec<Instance>>\n) -> Result<(), anyhow::Error> {\n    Ok(for set in sets {\n        for (name, alg) in algs.iter() {\n            let mut group = c.benchmark_group(format!(\"{}-{}\", set, name));\n            group.sample_size(10).warm_up_time(Duration::from_millis(200));\n\n            for n in ns {\n                if !ranges.get(*name).filter(|r| r.contains(&n)).is_some()\n                || (*name == \"bb\" && *n > 22 && *set == \"ZKW\") {\n                    continue;\n                }\n\n                let (max, avg, nonzero_n) =\n                    measure(&mut group, *alg, &solutions[set], *n, &input[&(*set, *n)]);\n                eprintln!(\"max: {}, avg: {}, n: {} vs real n: {}\", max, avg, nonzero_n, n);\n                let avg = avg / nonzero_n as f64;\n\n                let mut file = File::create(format!(\"../docs/measurements/{}_{}_{}.txt\", set, name, n))?;\n                file.write_all(format!(\"max,avg\\n{},{}\", max, avg).as_bytes())?;\n            }\n            group.finish();\n        }\n    })\n}\n\nfn measure(\n    group: &mut criterion::BenchmarkGroup<criterion::measurement::WallTime>,\n    alg: for<'a> fn(&'a Instance) -> Solution<'a>,\n    solutions: &HashMap<(u32, i32), OptimalSolution>,\n    n: u32,\n    instances: &Vec<Instance>\n) -> (f64, f64, u32) {\n    let mut stats = (0.0, 0.0, 0);\n    group.bench_with_input(\n        BenchmarkId::from_parameter(n),\n        instances,\n        |b, ins| b.iter(\n            || ins.iter().for_each(|inst| {\n                let sln = alg(inst);\n                let optimal = &solutions[&(n, inst.id)];\n                if optimal.cost != 0 {\n                    let error = 1.0 - sln.cost as f64 / optimal.cost as f64;\n                    let (max, avg, n) = stats;\n                    stats = (if error > max { error } else { max }, avg + error, n + 1);\n                }\n            })\n        )\n    );\n\n    stats\n}\n\nfn load_input(set: &str, r: Range<u32>) -> Result<Vec<Instance>> {\n    let mut instances = Vec::new();\n\n    for file in list_input_files(set, r)? {\n        let file = file?;\n        let mut r = BufReader::new(File::open(file.path())?);\n        while let Some(inst) = parse_line(&mut r)? {\n            instances.push(inst);\n        }\n    }\n\n    Ok(instances)\n}\n\nfn proxy(c: &mut Criterion) {\n    full(c).unwrap()\n}\n\ncriterion_group!(benches, proxy);\ncriterion_main!(benches);"]},{"t":"Header","c":[3,["spouštění-jednotlivých-řešičů",[],[]],[{"t":"Str","c":"Spouštění"},{"t":"Space"},{"t":"Str","c":"jednotlivých"},{"t":"Space"},{"t":"Str","c":"řešičů"}]]},{"t":"Para","c":[{"t":"Str","c":"Projekt"},{"t":"Space"},{"t":"Str","c":"podporuje"},{"t":"Space"},{"t":"Str","c":"sestavení"},{"t":"Space"},{"t":"Str","c":"spustitelného"},{"t":"Space"},{"t":"Str","c":"souboru"},{"t":"Space"},{"t":"Str","c":"schopného"},{"t":"Space"},{"t":"Str","c":"zpracovat"},{"t":"Space"},{"t":"Str","c":"libovolný"},{"t":"SoftBreak"},{"t":"Str","c":"vstup"},{"t":"Space"},{"t":"Str","c":"ze"},{"t":"Space"},{"t":"Str","c":"zadání"},{"t":"Space"},{"t":"Str","c":"za"},{"t":"Space"},{"t":"Str","c":"pomoci"},{"t":"Space"},{"t":"Str","c":"algoritmu"},{"t":"Space"},{"t":"Str","c":"zvoleného"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"příkazové"},{"t":"Space"},{"t":"Str","c":"řádce."},{"t":"Space"},{"t":"Str","c":"Zdrojový"},{"t":"Space"},{"t":"Str","c":"kód"},{"t":"SoftBreak"},{"t":"Str","c":"tohoto"},{"t":"Space"},{"t":"Str","c":"rozhraní"},{"t":"Space"},{"t":"Str","c":"se"},{"t":"Space"},{"t":"Str","c":"nachází"},{"t":"Space"},{"t":"Str","c":"v"},{"t":"Space"},{"t":"Str","c":"souboru"},{"t":"Space"},{"t":"Code","c":[["",[],[]],"solver/src/bin/main.rs"]},{"t":"Str","c":"."},{"t":"Space"},{"t":"Str","c":"Na"},{"t":"Space"},{"t":"Str","c":"standardní"},{"t":"SoftBreak"},{"t":"Str","c":"výstup"},{"t":"Space"},{"t":"Str","c":"vypisuje"},{"t":"Space"},{"t":"Str","c":"cenu"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"chybu"},{"t":"Space"},{"t":"Str","c":"řešení,"},{"t":"Space"},{"t":"Str","c":"spoléhá"},{"t":"Space"},{"t":"Str","c":"ovšem"},{"t":"Space"},{"t":"Str","c":"na"},{"t":"Space"},{"t":"Str","c":"to,"},{"t":"Space"},{"t":"Str","c":"že"},{"t":"Space"},{"t":"Str","c":"mezi"},{"t":"Space"},{"t":"Str","c":"optimálními"},{"t":"SoftBreak"},{"t":"Str","c":"řešeními"},{"t":"Space"},{"t":"Str","c":"najde"},{"t":"Space"},{"t":"Str","c":"i"},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Str","c":"pro"},{"t":"Space"},{"t":"Str","c":"kombinaci"},{"t":"Space"},{"t":"Str","c":"velikosti"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"ID"},{"t":"Space"},{"t":"Str","c":"zadané"},{"t":"Space"},{"t":"Str","c":"instance."}]},{"t":"CodeBlock","c":[["",["rust"],[["file","solver/src/bin/main.rs"]]],"extern crate solver;\n\nuse std::mem::size_of;\n\nuse rayon::prelude::*;\nuse solver::*;\nuse anyhow::{Result, anyhow};\n\nfn main() -> Result<()> {\n    let evo_config: EvolutionaryConfig = serde_json::from_str(std::env::args()\n        .collect::<Vec<_>>()\n        .get(1)\n        .ok_or_else(|| anyhow!(\"Expected the evolutionary configuration in JSON format as the first argument\"))?)?;\n\n    let solutions = load_solutions(evo_config.set)?;\n    let rng: rand_chacha::ChaCha8Rng = rand::SeedableRng::seed_from_u64(42);\n\n    println!(\n        \"info:\\n\\\n        |   Id size: {}\\n\\\n        |   Literal size: {}\\n\\\n        |   Clause size: {}\\n\\\n        |   Config size: {}\\n\\\n        |   Solution size: {}\\n\\\n        |   Instance size: {}\\n\\\n        \",\n        size_of::<Id>(),\n        size_of::<Literal>(),\n        size_of::<Clause>(),\n        size_of::<Config>(),\n        size_of::<Solution>(),\n        size_of::<Instance>(),\n    );\n\n    let mut instances = load_instances(evo_config.set)?\n        .into_par_iter()\n        .map(|inst| (inst.clone().into(), inst))\n        .collect::<Vec<(InstanceParams, _)>>();\n    instances.par_sort_unstable_by(|(p1, i1), (p2, i2)|\n        p1.cmp(p2).then(i1.id.cmp(&i2.id))\n    );\n\n    solutions.iter().for_each(|((params, _), opt)| {\n        // some instances (e.g. 33 in M1) have been removed,\n        // but their optimal solutions are still here\n        if let Ok(inst_index) = instances.binary_search_by(\n            |(p, inst)| p.cmp(params).then(inst.id.cmp(&opt.id))\n        ) {\n            let inst = &instances[inst_index].1;\n            let sln = Solution::new(opt.weight, opt.cfg, inst);\n            assert!(sln.valid(),\n                \"optimal solution to instance {} is invalid (satisfied: {})\\n{}\",\n                inst.id,\n                sln.satisfied,\n                opt.dump(),\n            );\n        }\n    });\n\n    instances.into_iter().take(evo_config.n_instances as usize).for_each(|(_params, inst)| {\n        use std::time::Instant;\n\n        // println!(\"solving {} ({:?} from set {})\", inst.id, params, evo_config.set);\n\n        let mut rng = rng.clone();\n        let optimal = solutions.get(&(inst.clone().into(), inst.id));\n        let now = Instant::now();\n        let sln = inst.evolutionary(&mut rng, evo_config, optimal);\n        let time = now.elapsed().as_millis();\n\n        let error = optimal.map(|opt| 1.0 - sln.weight as f64 / opt.weight as f64);\n        println!(\"done: {time} {id} {satisfied} {valid} {weight} {err}\",\n            time = time,\n            id = inst.id,\n            satisfied = sln.satisfied,\n            valid = sln.valid(),\n            weight = sln.weight,\n            err = error.map(|e| e.to_string()).unwrap_or_default()\n        );\n        assert!(!sln.satisfied || sln.valid(),\n            \"the following satisfied solution isn't valid! Instance {}:\\n{}\",\n            inst.id,\n            sln.dump()\n        );\n        assert!(!sln.satisfied || error.is_none() || error.unwrap() >= 0.0,\n            \"the following satisfied solution has a negative error of {:?}!\\n{}\\nInstance {}:\\n{}\",\n            error,\n            sln.dump(),\n            inst.id,\n            inst.dump(),\n        );\n\n        // println!(\"ours:    {}\", sln.dump());\n        // println!(\"optimal: {}\\n\", optimal.map(|opt| opt.dump()).unwrap_or_else(|| \"None\".into()));\n    });\n    Ok(())\n}"]},{"t":"Para","c":[{"t":"Str","c":"Funkci"},{"t":"Space"},{"t":"Str","c":"příslušnou"},{"t":"Space"},{"t":"Str","c":"vybranému"},{"t":"Space"},{"t":"Str","c":"algoritmu"},{"t":"Space"},{"t":"Str","c":"vrátíme"},{"t":"Space"},{"t":"Str","c":"jako"},{"t":"Space"},{"t":"Str","c":"hodnotu"},{"t":"Space"},{"t":"Str","c":"tohoto"},{"t":"Space"},{"t":"Str","c":"bloku:"}]},{"t":"CodeBlock","c":[["select-algorithm",["rust","bootstrap-fold"],[]],"let args: Vec<String> = std::env::args().collect();\nif args.len() >= 2 {\n    let alg = &args[1][..];\n    if let Some(&f) = algorithms.get(alg) {\n        Ok(Right(f))\n    } else if alg == \"sa\" { #[allow(clippy::or_fun_call)] { // simulated annealing\n        let mut iter = args[2..].iter().map(|str| &str[..]);\n        let max_iterations = iter.next().ok_or(anyhow!(\"not enough params\"))?.parse()?;\n        let scaling_factor = iter.next().ok_or(anyhow!(\"not enough params\"))?.parse()?;\n        let temp_modifier = iter.next().ok_or(anyhow!(\"not enough params\"))?.parse()?;\n        let equilibrium_width = iter.next().ok_or(anyhow!(\"not enough params\"))?.parse()?;\n        Ok(Left((max_iterations, scaling_factor, temp_modifier, equilibrium_width)))\n    } } else {\n        Err(anyhow!(\"\\\"{}\\\" is not a known algorithm\", alg))\n    }\n} else {\n    println!(\n        \"Usage: {} <algorithm>\\n\\twhere <algorithm> is one of {}\\n\\tor 'sa' for simulated annealing.\",\n        args[0],\n        algorithms.keys().map(ToString::to_string).collect::<Vec<_>>().join(\", \")\n    );\n    Err(anyhow!(\"Expected 1 argument, got {}\", args.len() - 1))\n}"]},{"t":"Header","c":[3,["automatické-testy",[],[]],[{"t":"Str","c":"Automatické"},{"t":"Space"},{"t":"Str","c":"testy"}]]},{"t":"Para","c":[{"t":"Str","c":"Implementaci"},{"t":"Space"},{"t":"Str","c":"doplňují"},{"t":"Space"},{"t":"Str","c":"automatické"},{"t":"Space"},{"t":"Str","c":"testy"},{"t":"Space"},{"t":"Str","c":"k"},{"t":"Space"},{"t":"Str","c":"ověření"},{"t":"Space"},{"t":"Str","c":"správnosti,"},{"t":"Space"},{"t":"Str","c":"včetně"},{"t":"SoftBreak"},{"t":"Str","c":"property-based"},{"t":"Space"},{"t":"Str","c":"testu"},{"t":"Space"},{"t":"Str","c":"s"},{"t":"Space"},{"t":"Str","c":"knihovnou"},{"t":"SoftBreak"},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"quickcheck"}],["https://github.com/BurntSushi/quickcheck",""]]},{"t":"Str","c":"."}]},{"t":"CodeBlock","c":[["tests",["rust","bootstrap-fold"],[]],"#[cfg(test)]\nmod tests {\n    use super::*;\n    use quickcheck::{Arbitrary, Gen};\n\n    #[derive(Clone, Debug)]\n    #[repr(transparent)]\n    struct ArrayVecProxy<T, const CAP: usize>(ArrayVec<T, CAP>);\n\n    type LiteralProxy = ArrayVecProxy<Literal, 3>;\n    type ClauseProxy = ArrayVecProxy<LiteralProxy, MAX_CLAUSES>;\n\n    impl<T, const CAP: usize> From<ArrayVec<T, CAP>> for ArrayVecProxy<T, CAP> {\n        fn from(av: ArrayVec<T, CAP>) -> Self {\n            ArrayVecProxy(av)\n        }\n    }\n\n    impl<T, const CAP: usize> From<ArrayVecProxy<T, CAP>> for ArrayVec<T, CAP> {\n        fn from(ArrayVecProxy(av): ArrayVecProxy<T, CAP>) -> Self {\n            av\n        }\n    }\n\n    impl<T: Arbitrary + core::fmt::Debug, const CAP: usize> Arbitrary for ArrayVecProxy<T, CAP> {\n        fn arbitrary(g: &mut Gen) -> Self {\n            let arr: [T; CAP] = Vec::arbitrary(g)\n                .into_iter()\n                .take(CAP)\n                .collect::<Vec<_>>()\n                .try_into()\n                .unwrap();\n            ArrayVecProxy(arr.into())\n        }\n\n        fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {\n            Box::new(self.0.clone()\n                .into_iter()\n                .collect::<Vec<T>>()\n                .shrink()\n                .map(|vec| {\n                    let arr: [T; CAP] = vec.try_into().unwrap();\n                    ArrayVecProxy(arr.into())\n                })\n            )\n        }\n    }\n\n    impl Arbitrary for Literal {\n        fn arbitrary(g: &mut Gen) -> Self {\n            Literal(bool::arbitrary(g), Id::arbitrary(g))\n        }\n    }\n\n    impl Arbitrary for Instance {\n        fn arbitrary(g: &mut Gen) -> Instance {\n            let proxy: ArrayVec<LiteralProxy, MAX_CLAUSES> = (ArrayVecProxy::arbitrary(g) as ClauseProxy).into();\n            Instance {\n                id:      i32::arbitrary(g),\n                weights: ArrayVecProxy::arbitrary(g).into(),\n                clauses: proxy.into_iter().map(|clause| clause.0.into_inner().unwrap()).collect(),\n            }\n        }\n\n        fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {\n            let data = self.clone();\n            #[allow(clippy::needless_collect)]\n            let chain: Vec<Instance> = quickcheck::empty_shrinker()\n                .chain(self.id.shrink().map(|id| Instance {id, ..(&data).clone()}))\n                .chain(ArrayVecProxy(self.weights.clone())\n                    .shrink()\n                    .map(|weights| Instance {\n                        weights: weights.into(),\n                        ..(&data).clone()\n                    })\n                )\n                .chain(ArrayVecProxy(\n                        self.clauses.clone()\n                            .into_iter()\n                            .map(|c| ArrayVecProxy(c.into()))\n                            .collect()\n                    )\n                    .shrink()\n                    .map(|clauses| {\n                        let av: ArrayVec<LiteralProxy, MAX_CLAUSES> = clauses.into();\n                        Instance {\n                            clauses: av.into_iter().map(|clause| clause.0.into_inner().unwrap()).collect(),\n                            ..(&data).clone()\n                        }\n                    })\n                    .filter(|i| !i.clauses.is_empty())\n                )\n                .collect();\n            Box::new(chain.into_iter())\n        }\n    }\n}\n"]}]}